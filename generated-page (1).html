<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID. Studio — Video Clipper Interface</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500;700&family=Space+Grotesk:wght@400;500;700&family=Syne:wght@500;700;800&display=swap" rel="stylesheet">
    
    
    <!-- Iconify -->
    <script src="https://code.iconify.design/iconify-icon/1.0.8/iconify-icon.min.js"></script>
    
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        display: ['Syne', 'sans-serif'],
                        body: ['Space Grotesk', 'sans-serif'],
                    },
                    colors: {
                        bg: '#060606',
                        'bg-alt': '#0d0d0d',
                        accent: '#c8ff00',
                        accent2: '#ff0040',
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                        'slide-up': 'slideUp 0.5s ease-out forwards',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        },
                        slideUp: {
                            '0%': { opacity: '0', transform: 'translateY(20px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    }
                }
            }
        }
    </script>

    <style>
        :root {
            --bg: #060606;
            --bg-alt: #0d0d0d;
            --accent: #c8ff00;
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        ::selection { background: var(--accent); color: var(--bg); }
        html { scrollbar-width: thin; scrollbar-color: var(--accent) var(--bg); scroll-behavior: smooth; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 2px; }

        body {
            background-color: var(--bg);
            color: #f0f0f0;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            background-image: radial-gradient(circle, rgba(255,255,255,0.012) 1px, transparent 1px);
            background-size: 24px 24px;
        }

        .scroll-progress {
            position: fixed; top: 0; left: 0; z-index: 999;
            height: 2px; background: var(--accent); width: 100%;
            transform-origin: left; transform: scaleX(0); will-change: transform;
            box-shadow: 0 0 8px var(--accent);
        }
        .grain {
            position: fixed; inset: 0; z-index: 9000; pointer-events: none; opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
            background-repeat: repeat; background-size: 180px;
        }
        .canvas-wrap { position: fixed; inset: 0; z-index: 0; pointer-events: none; }
        .canvas-wrap canvas { display: block; width: 100%; height: 100%; }
        .canvas-wrap::after {
            content: ''; position: absolute; inset: 0; pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(6,6,6,0.7) 100%);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 12px; height: 12px;
            background: #fff; border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(200,255,0,0.5);
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(200,255,0,0.5); }

        #automationBoardViewport {
            touch-action: none;
            cursor: grab;
        }
        #automationBoardViewport.is-panning {
            cursor: grabbing;
        }
        #automationBoardSurface {
            transform-origin: 0 0;
            will-change: transform;
            touch-action: none;
        }
        .automar-node {
            touch-action: none;
            cursor: grab;
            user-select: none;
        }
        .automar-node.is-dragging {
            cursor: grabbing;
            z-index: 50;
        }
        .automation-link {
            stroke: url(#automarFlowLine);
            stroke-width: 3;
            fill: none;
            opacity: 0.88;
        }
        .timeline-shell {
            position: relative;
            background:
                radial-gradient(circle at 12% 10%, rgba(200, 255, 0, 0.14), transparent 36%),
                radial-gradient(circle at 88% 86%, rgba(70, 190, 255, 0.16), transparent 42%),
                linear-gradient(155deg, rgba(5, 10, 20, 0.98), rgba(6, 12, 24, 0.94));
            box-shadow:
                0 45px 90px rgba(0, 0, 0, 0.7),
                inset 0 0 0 1px rgba(176, 225, 70, 0.18),
                inset 0 0 38px rgba(145, 218, 44, 0.12);
        }
        .timeline-shell::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            background-image:
                radial-gradient(circle at 20% 22%, rgba(255, 255, 255, 0.16) 0 1px, transparent 2px),
                radial-gradient(circle at 78% 30%, rgba(206, 255, 102, 0.22) 0 1px, transparent 3px),
                radial-gradient(circle at 64% 73%, rgba(118, 223, 255, 0.2) 0 1px, transparent 3px),
                radial-gradient(circle at 38% 84%, rgba(255, 255, 255, 0.14) 0 1px, transparent 2px);
            opacity: 0.35;
        }
        .timeline-shell::after {
            content: '';
            position: absolute;
            inset: 1px;
            pointer-events: none;
            border-radius: 28px;
            border: 1px solid rgba(180, 250, 70, 0.14);
            box-shadow: inset 0 0 40px rgba(200, 255, 0, 0.08);
        }
        .timeline-shell-inner {
            position: relative;
            z-index: 1;
        }
        .timeline-glass {
            border: 1px solid rgba(176, 225, 70, 0.16);
            background: linear-gradient(160deg, rgba(7, 12, 24, 0.86), rgba(2, 5, 12, 0.76));
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03), 0 18px 44px rgba(0, 0, 0, 0.44);
            backdrop-filter: blur(12px);
        }
        .timeline-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.62rem;
            border: 1px solid rgba(188, 255, 72, 0.4);
            border-radius: 0.72rem;
            background: rgba(154, 255, 73, 0.08);
            color: #cfff6d;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-size: 0.66rem;
            font-weight: 700;
        }
        .timeline-chip-btn {
            border: 1px solid rgba(188, 255, 72, 0.42);
            background: rgba(142, 225, 60, 0.12);
            color: #d4ff77;
            box-shadow: inset 0 0 14px rgba(154, 255, 73, 0.13);
        }
        .timeline-chip-btn:hover {
            background: rgba(188, 255, 72, 0.22);
        }
        .timeline-white-btn {
            border: 1px solid rgba(255, 255, 255, 0.32);
            background: rgba(255, 255, 255, 0.95);
            color: #111827;
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.36);
        }
        .timeline-ruler {
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr));
            gap: 0.25rem;
            color: rgba(255, 255, 255, 0.48);
            font-size: 0.68rem;
            margin-bottom: 0.45rem;
            padding-left: 76px;
        }
        .timeline-track-grid {
            position: relative;
            border: 1px solid rgba(176, 225, 70, 0.16);
            border-radius: 14px;
            overflow: hidden;
            background:
                linear-gradient(180deg, rgba(8, 16, 32, 0.82), rgba(3, 8, 18, 0.92)),
                repeating-linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 0, rgba(255, 255, 255, 0.05) 1px, transparent 1px, transparent 64px),
                repeating-linear-gradient(to right, rgba(255, 255, 255, 0.06) 0, rgba(255, 255, 255, 0.06) 1px, transparent 1px, transparent 56px);
            box-shadow: inset 0 0 26px rgba(152, 255, 67, 0.08);
        }
        .timeline-track-row {
            display: grid;
            grid-template-columns: 78px minmax(0, 1fr);
            align-items: center;
            min-height: 64px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }
        .timeline-track-row:last-child {
            border-bottom: 0;
        }
        .timeline-track-label {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.72rem;
            letter-spacing: 0.03em;
            color: rgba(230, 241, 255, 0.76);
            padding-left: 0.6rem;
        }
        .timeline-row-lane {
            position: relative;
            height: 100%;
            padding: 0.45rem 0.65rem;
        }
        .timeline-clip-pill {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 10px;
            border: 1px solid rgba(188, 255, 72, 0.5);
            background: linear-gradient(145deg, rgba(150, 255, 70, 0.24), rgba(87, 150, 50, 0.5));
            color: rgba(247, 255, 226, 0.95);
            font-size: 0.92rem;
            letter-spacing: 0.02em;
            padding: 0.52rem 0.82rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: inset 0 0 26px rgba(200, 255, 80, 0.22), 0 0 24px rgba(200, 255, 80, 0.18);
        }
        .timeline-clip-pill.blue {
            border-color: rgba(100, 214, 255, 0.44);
            background: linear-gradient(145deg, rgba(58, 114, 214, 0.32), rgba(22, 56, 122, 0.62));
            box-shadow: inset 0 0 22px rgba(94, 194, 255, 0.18), 0 0 20px rgba(50, 165, 255, 0.14);
        }
        .timeline-clip-pill.purple {
            border-color: rgba(208, 148, 255, 0.42);
            background: linear-gradient(145deg, rgba(164, 94, 242, 0.33), rgba(84, 35, 140, 0.66));
            box-shadow: inset 0 0 22px rgba(205, 130, 255, 0.19), 0 0 20px rgba(197, 95, 255, 0.15);
        }
        .timeline-wave {
            position: absolute;
            right: 2%;
            top: 50%;
            transform: translateY(-50%);
            height: 14px;
            width: 36%;
            border-radius: 999px;
            background: repeating-linear-gradient(to right, rgba(160, 235, 255, 0.8) 0 2px, transparent 2px 6px);
            opacity: 0.72;
        }
        .timeline-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, rgba(220, 255, 150, 0.96), rgba(160, 255, 66, 0.96));
            box-shadow: 0 0 22px rgba(188, 255, 74, 0.85);
            pointer-events: none;
            transform: translateX(-1px);
            left: 0;
            transition: left 120ms linear;
            z-index: 20;
        }
        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: 0;
            left: -5px;
            width: 12px;
            height: 12px;
            border-radius: 999px;
            background: #d6ff7b;
            box-shadow: 0 0 16px rgba(188, 255, 72, 0.8);
        }
        .timeline-playhead-tag {
            position: absolute;
            bottom: -23px;
            left: 50%;
            transform: translateX(-50%);
            color: #d2ff70;
            font-size: 0.78rem;
            font-family: 'JetBrains Mono', monospace;
            text-shadow: 0 0 12px rgba(188, 255, 72, 0.65);
            white-space: nowrap;
        }
        .timeline-side-panel {
            border: 1px solid rgba(176, 225, 70, 0.18);
            border-radius: 16px;
            background: linear-gradient(170deg, rgba(10, 18, 32, 0.87), rgba(3, 8, 18, 0.88));
            box-shadow: inset 0 0 20px rgba(186, 255, 72, 0.08);
        }
        .timeline-tab-strip {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 0.2rem;
            border-bottom: 1px solid rgba(176, 225, 70, 0.14);
            padding-bottom: 0.6rem;
            margin-bottom: 0.8rem;
        }
        .timeline-tab {
            text-align: center;
            color: rgba(255, 255, 255, 0.54);
            font-size: 0.76rem;
        }
        .timeline-tab.active {
            color: #d8ff7f;
            text-shadow: 0 0 12px rgba(188, 255, 72, 0.45);
        }
        .timeline-toggle {
            border: 1px solid rgba(176, 225, 70, 0.16);
            border-radius: 12px;
            background: rgba(1, 4, 10, 0.55);
            padding: 0.55rem 0.65rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: rgba(235, 246, 255, 0.84);
            font-size: 0.88rem;
        }
        .timeline-toggle-dot {
            width: 30px;
            height: 17px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(137, 229, 55, 0.4), rgba(188, 255, 72, 0.98));
            position: relative;
            box-shadow: 0 0 12px rgba(188, 255, 72, 0.45);
        }
        .timeline-toggle-dot::after {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            width: 13px;
            height: 13px;
            border-radius: 999px;
            background: #101419;
        }
        .timeline-soft-label {
            font-size: 0.66rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.42);
        }
    </style>
</head>
<body class="font-body relative min-h-screen">

    <div class="scroll-progress" id="scrollProgress"></div>
    <div class="grain"></div>
    <div class="canvas-wrap">
        <canvas id="voidCanvas"></canvas>
    </div>

    <!-- Landing Page -->
    <div id="landing-page" class="relative z-10 min-h-screen flex flex-col items-center justify-center px-6 transition-opacity duration-500">
        <!-- Logo -->
        <div class="absolute top-8 left-8">
            <span class="font-display text-lg font-bold tracking-widest text-white">VOID<span class="text-accent">.</span></span>
        </div>

        <div class="max-w-3xl mx-auto w-full text-center flex flex-col items-center animate-slide-up">
            <div class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 border border-white/10 text-xs font-medium text-white/70 mb-8 backdrop-blur-sm">
                <span class="w-2 h-2 rounded-full bg-accent animate-pulse"></span>
                v2.0 Beta is live
            </div>
            
            <h1 class="font-display text-5xl sm:text-6xl md:text-7xl font-semibold tracking-tighter text-white mb-6 leading-tight">
                Extract <span class="text-accent italic pr-2">Viral</span> Shorts <br> from Long Videos.
            </h1>
            
            <p class="text-sm md:text-base text-white/50 font-light max-w-xl mx-auto mb-10 leading-relaxed">
                Paste a link or upload a file. Our AI analyzes the content, finds the most engaging hooks, and generates ready-to-post clips with captions in seconds.
            </p>

            <form id="earlyAccessForm" class="w-full max-w-md flex flex-col sm:flex-row gap-3">
                <input type="email" placeholder="name@company.com" class="flex-grow bg-black/60 border border-white/10 rounded-xl py-4 px-5 text-sm text-white outline-none focus:border-accent/50 focus:bg-black/80 transition-all font-body placeholder:text-white/30 backdrop-blur-md">
                <button type="submit" id="earlyAccessBtn" class="bg-white text-bg px-8 py-4 rounded-xl font-display font-semibold text-sm hover:bg-accent hover:shadow-[0_0_25px_rgba(200,255,0,0.25)] hover:-translate-y-0.5 transition-all whitespace-nowrap flex items-center justify-center gap-2">
                    Get Early Access
                    <iconify-icon icon="solar:arrow-right-linear" width="16" height="16"></iconify-icon>
                </button>
            </form>
            
            <div class="mt-8 flex items-center gap-6 text-xs text-white/30 font-light">
                <span class="flex items-center gap-1"><iconify-icon icon="solar:check-circle-linear"></iconify-icon> No credit card required</span>
                <span class="flex items-center gap-1"><iconify-icon icon="solar:check-circle-linear"></iconify-icon> Cancel anytime</span>
            </div>
        </div>
    </div>

    <!-- Main App Interface (Initially Hidden) -->
    <div id="app-interface" class="hidden opacity-0 transition-opacity duration-700 pb-20">
        <!-- Navigation -->
        <nav class="fixed top-0 left-0 right-0 z-[100] flex items-center justify-between px-6 py-4 bg-black/50 backdrop-blur-xl border-b border-white/5 transition-all">
            <div class="flex items-center gap-12">
                <a class="font-display text-lg font-bold tracking-widest text-white" href="#" id="homeLink">VOID<span class="text-accent">.</span></a>
                <div class="hidden md:flex gap-8">
                    <a href="#" class="text-xs font-medium text-accent border-b border-accent pb-1">Dashboard</a>
                    <a href="#" class="text-xs font-normal text-white/50 hover:text-white transition-colors">Projects</a>
                    <a href="#" class="text-xs font-normal text-white/50 hover:text-white transition-colors">Templates</a>
                    <a href="#" class="text-xs font-normal text-white/50 hover:text-white transition-colors">Brand Kit</a>
                </div>
            </div>
            <div class="flex items-center gap-6">
                <div class="flex items-center gap-2 text-xs text-white/40">
                    <iconify-icon icon="solar:database-linear" width="14" height="14"></iconify-icon>
                    <span>120 / 300 mins left</span>
                </div>
                <button class="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center border border-white/20 hover:border-accent transition-colors">
                    <iconify-icon icon="solar:user-rounded-linear" class="text-white text-sm" width="16" height="16"></iconify-icon>
                </button>
            </div>
        </nav>

        <main class="relative z-10 max-w-[1400px] mx-auto pt-32 px-4 sm:px-6 lg:px-8 flex flex-col gap-16">

            <!-- 1. Input / Generation Block -->
            <section id="inputSection" class="relative w-full max-w-4xl mx-auto">
                <div class="absolute -top-1/2 left-1/2 -translate-x-1/2 w-[600px] h-[600px] bg-accent/10 blur-[120px] rounded-full pointer-events-none"></div>
                
                <div class="relative bg-white/[0.02] border border-white/10 rounded-2xl p-8 sm:p-10 backdrop-blur-xl overflow-hidden shadow-2xl">
                    <div class="text-center mb-8">
                        <h2 class="font-display text-2xl sm:text-3xl font-semibold tracking-tight text-white mb-3">Create New Project</h2>
                        <p class="text-xs sm:text-sm text-white/50 font-light max-w-xl mx-auto">Paste a link or upload a file to generate clips instantly.</p>
                    </div>

                    <form id="generateForm" class="flex flex-col gap-4">
                        <div class="flex flex-col sm:flex-row gap-3">
                            <div class="relative flex-grow">
                                <div class="absolute inset-y-0 left-4 flex items-center pointer-events-none">
                                    <iconify-icon icon="solar:link-circle-linear" class="text-white/40 text-xl" width="20" height="20"></iconify-icon>
                                </div>
                                <input type="text" id="videoUrlInput" placeholder="Paste YouTube or Drive URL here..." class="w-full bg-black/60 border border-white/10 rounded-xl py-4 pl-12 pr-4 text-sm text-white outline-none focus:border-accent/50 focus:bg-black/80 transition-all font-body placeholder:text-white/30 shadow-inner">
                            </div>
                            <button type="submit" id="generateBtn" class="bg-accent text-bg px-8 py-4 rounded-xl font-display font-semibold text-sm hover:shadow-[0_0_25px_rgba(200,255,0,0.25)] hover:-translate-y-0.5 transition-all whitespace-nowrap flex items-center justify-center gap-2">
                                <iconify-icon icon="solar:magic-stick-3-linear" class="text-lg" width="18" height="18"></iconify-icon>
                                <span>Generate Clips</span>
                            </button>
                        </div>

                        <div class="flex items-center gap-4 text-xs text-white/30 font-light my-2">
                            <div class="h-[1px] flex-grow bg-white/5"></div>
                            <span class="uppercase tracking-widest text-xs">Or</span>
                            <div class="h-[1px] flex-grow bg-white/5"></div>
                        </div>

                        <!-- Drag & Drop -->
                        <label id="dropZone" class="border border-dashed border-white/15 rounded-xl py-10 flex flex-col items-center justify-center cursor-pointer hover:border-accent/40 hover:bg-white/[0.02] transition-colors group relative">
                            <input type="file" class="hidden" accept="video/*" id="fileInput">
                            <div class="w-12 h-12 rounded-full bg-white/5 flex items-center justify-center mb-3 group-hover:scale-110 transition-transform duration-300">
                                <iconify-icon icon="solar:upload-minimalistic-linear" class="text-2xl text-white/60 group-hover:text-accent transition-colors" width="24" height="24"></iconify-icon>
                            </div>
                            <span class="text-sm text-white/80 font-medium mb-1" id="dropText">Click to upload or drag &amp; drop</span>
                            <span class="text-xs text-white/40 font-light">MP4, MOV, WEBM (Max 2GB)</span>
                        </label>
                        <p id="generateStatus" class="text-xs text-white/50 min-h-[1.2rem]"></p>

                        <div class="rounded-xl border border-white/10 bg-black/20 p-4 sm:p-5 space-y-4">
                            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                                <h3 class="text-xs font-semibold text-white/70 tracking-widest uppercase">Fluxo Guiado</h3>
                                <span id="workflowStageBadge" class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-white/5 border border-white/10 text-[11px] text-white/50">
                                    Etapa 1/5
                                </span>
                            </div>
                            <p id="workflowNextAction" class="text-xs text-white/70 leading-relaxed">
                                Próximo passo: cole um link de vídeo (YouTube) ou envie um arquivo.
                            </p>
                            <div class="grid grid-cols-2 sm:grid-cols-5 gap-2 text-[11px]">
                                <div id="wfSourceCard" class="rounded-lg border border-accent/40 bg-accent/[0.06] px-2 py-2">
                                    <p class="text-white/80 font-medium">1. Fonte</p>
                                    <p id="wfSourceState" class="text-accent mt-1">Em andamento</p>
                                </div>
                                <div id="wfClipsCard" class="rounded-lg border border-white/10 bg-white/[0.01] px-2 py-2">
                                    <p class="text-white/70 font-medium">2. Clips</p>
                                    <p id="wfClipsState" class="text-white/40 mt-1">Pendente</p>
                                </div>
                                <div id="wfEditorCard" class="rounded-lg border border-white/10 bg-white/[0.01] px-2 py-2">
                                    <p class="text-white/70 font-medium">3. Editor</p>
                                    <p id="wfEditorState" class="text-white/40 mt-1">Pendente</p>
                                </div>
                                <div id="wfCaptionCard" class="rounded-lg border border-white/10 bg-white/[0.01] px-2 py-2">
                                    <p class="text-white/70 font-medium">4. Legendas</p>
                                    <p id="wfCaptionState" class="text-white/40 mt-1">Pendente</p>
                                </div>
                                <div id="wfDeliveryCard" class="rounded-lg border border-white/10 bg-white/[0.01] px-2 py-2">
                                    <p class="text-white/70 font-medium">5. Entrega</p>
                                    <p id="wfDeliveryState" class="text-white/40 mt-1">Pendente</p>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-2">
                                <button type="button" id="guideFocusSourceBtn" class="text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors">Ir para Fonte</button>
                                <button type="button" id="guideOpenEditorBtn" class="text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors disabled:opacity-40 disabled:cursor-not-allowed">Abrir 1º Clip</button>
                                <button type="button" id="guideTranscribeBtn" class="text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors disabled:opacity-40 disabled:cursor-not-allowed">Reajustar</button>
                                <button type="button" id="guideExportBtn" class="text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors disabled:opacity-40 disabled:cursor-not-allowed">Exportar</button>
                                <button type="button" id="guidePackBtn" class="text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors disabled:opacity-40 disabled:cursor-not-allowed">Gerar Pack</button>
                                <button type="button" id="guideDiagnoseBtn" class="text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors">Diagnosticar</button>
                            </div>
                            <p id="backendStatus" class="text-[11px] text-white/40 min-h-[1rem]">Checando backend...</p>
                        </div>
                    </form>
                </div>
            </section>

            <!-- 2. Updates / Results Feed (Hidden until generated) -->
            <section id="resultsSection" class="hidden opacity-0 transition-opacity duration-500">
                <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-8 gap-4">
                    <div>
                        <h2 class="font-display text-2xl font-semibold tracking-tight text-white flex items-center gap-3">
                            <iconify-icon icon="solar:gallery-video-linear" class="text-accent" width="24" height="24"></iconify-icon>
                            Generated Clips
                        </h2>
                        <p id="sourceSummary" class="text-xs text-white/40 mt-1">Source: No video loaded yet</p>
                    </div>
                    
                    <div class="flex flex-wrap items-center gap-2 bg-white/5 border border-white/10 p-1 rounded-lg backdrop-blur-md" id="filterContainer">
                        <button class="filter-btn active px-3 py-1.5 rounded bg-white/10 text-white text-xs font-medium shadow-sm" data-filter="all">All (3)</button>
                        <button class="filter-btn px-3 py-1.5 rounded hover:bg-white/5 text-white/50 hover:text-white transition-colors text-xs font-medium" data-filter="highscore">High Score</button>
                        <button class="filter-btn px-3 py-1.5 rounded hover:bg-white/5 text-white/50 hover:text-white transition-colors text-xs font-medium" data-filter="drafts">Drafts</button>
                        <div class="h-5 w-px bg-white/10 mx-1 hidden sm:block"></div>
                        <label class="flex items-center gap-1 text-[11px] text-white/50">
                            <span>Tema</span>
                            <select id="themeFilterSelect" class="bg-black/60 border border-white/15 rounded px-2 py-1 text-[11px] text-white/80 outline-none focus:border-accent/40">
                                <option value="all">Todos</option>
                            </select>
                        </label>
                        <label class="flex items-center gap-1 text-[11px] text-white/50">
                            <span>Assunto</span>
                            <select id="subjectFilterSelect" class="bg-black/60 border border-white/15 rounded px-2 py-1 text-[11px] text-white/80 outline-none focus:border-accent/40">
                                <option value="all">Todos</option>
                            </select>
                        </label>
                    </div>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6" id="clipGrid">
                    <!-- Clip Card 1 -->
                    <div class="clip-card group relative bg-white/[0.02] border border-white/10 rounded-xl overflow-hidden backdrop-blur-sm transition-all duration-400 hover:-translate-y-1 hover:border-accent/30 hover:shadow-[0_10px_40px_rgba(0,0,0,0.6)]" data-category="highscore">
                        <div class="relative aspect-[9/16] bg-black/80 overflow-hidden cursor-pointer play-trigger">
                            <img src="https://images.unsplash.com/photo-1720962158858-5fb16991d2b8?w=800&amp;q=80" alt="Thumbnail" class="absolute inset-0 w-full h-full object-cover opacity-50 group-hover:opacity-80 transition-opacity duration-500 group-hover:scale-105 transform">
                            <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                <div class="w-14 h-14 bg-black/40 backdrop-blur-md rounded-full flex items-center justify-center border border-white/20 hover:scale-110 transition-transform">
                                    <iconify-icon icon="solar:play-bold" class="text-white text-2xl translate-x-[2px]" width="24" height="24"></iconify-icon>
                                </div>
                            </div>
                            <div class="absolute top-3 left-3 bg-accent text-bg text-xs font-semibold tracking-wide uppercase px-2 py-1 rounded shadow-[0_0_15px_rgba(200,255,0,0.4)] flex items-center gap-1">
                                <iconify-icon icon="solar:flame-bold" width="12" height="12"></iconify-icon> Score 99
                            </div>
                            <div class="absolute bottom-3 right-3 bg-black/80 backdrop-blur-sm text-white/90 text-xs px-1.5 py-0.5 rounded border border-white/10 font-mono">0:58</div>
                        </div>
                        <div class="p-4 border-t border-white/5">
                            <h3 class="font-display font-medium text-sm text-white/90 line-clamp-2 leading-snug mb-4 group-hover:text-accent transition-colors clip-title">VR headsets will replace monitors in 3 years</h3>
                            <div class="flex items-center justify-between">
                                <span class="text-xs text-white/40 uppercase tracking-wider">Hook: Spatial</span>
                                <div class="flex gap-2">
                                    <button class="edit-btn w-8 h-8 flex items-center justify-center rounded-lg bg-white/5 hover:bg-white/15 border border-white/10 text-white/70 hover:text-white transition-colors" title="Edit">
                                        <iconify-icon icon="solar:pen-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                    <button class="w-8 h-8 flex items-center justify-center rounded-lg bg-accent/10 hover:bg-accent/20 border border-accent/20 text-accent transition-colors" title="Export">
                                        <iconify-icon icon="solar:download-minimalistic-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Clip Card 2 -->
                    <div class="clip-card group relative bg-white/[0.02] border border-white/10 rounded-xl overflow-hidden backdrop-blur-sm transition-all duration-400 hover:-translate-y-1 hover:border-accent/30 hover:shadow-[0_10px_40px_rgba(0,0,0,0.6)]" data-category="highscore">
                        <div class="relative aspect-[9/16] bg-black/80 overflow-hidden cursor-pointer play-trigger">
                            <img src="https://images.unsplash.com/photo-1720962158919-6c5f5f99630d?w=800&amp;q=80" alt="Thumbnail" class="absolute inset-0 w-full h-full object-cover opacity-50 group-hover:opacity-80 transition-opacity duration-500 group-hover:scale-105 transform">
                            <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                <div class="w-14 h-14 bg-black/40 backdrop-blur-md rounded-full flex items-center justify-center border border-white/20 hover:scale-110 transition-transform">
                                    <iconify-icon icon="solar:play-bold" class="text-white text-2xl translate-x-[2px]" width="24" height="24"></iconify-icon>
                                </div>
                            </div>
                            <div class="absolute top-3 left-3 bg-white text-bg text-xs font-semibold tracking-wide uppercase px-2 py-1 rounded flex items-center gap-1">
                                Score 85
                            </div>
                            <div class="absolute bottom-3 right-3 bg-black/80 backdrop-blur-sm text-white/90 text-xs px-1.5 py-0.5 rounded border border-white/10 font-mono">0:42</div>
                        </div>
                        <div class="p-4 border-t border-white/5">
                            <h3 class="font-display font-medium text-sm text-white/90 line-clamp-2 leading-snug mb-4 group-hover:text-accent transition-colors clip-title">Why Apple Vision Pro changes the design game</h3>
                            <div class="flex items-center justify-between">
                                <span class="text-xs text-white/40 uppercase tracking-wider">Hook: Design</span>
                                <div class="flex gap-2">
                                    <button class="edit-btn w-8 h-8 flex items-center justify-center rounded-lg bg-white/5 hover:bg-white/15 border border-white/10 text-white/70 hover:text-white transition-colors" title="Edit">
                                        <iconify-icon icon="solar:pen-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                    <button class="w-8 h-8 flex items-center justify-center rounded-lg bg-white/5 hover:bg-white/15 border border-white/10 text-white/70 hover:text-white transition-colors" title="Export">
                                        <iconify-icon icon="solar:download-minimalistic-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                     <!-- Clip Card 3 -->
                    <div class="clip-card group relative bg-white/[0.02] border border-white/10 rounded-xl overflow-hidden backdrop-blur-sm transition-all duration-400 hover:-translate-y-1 hover:border-accent/30 hover:shadow-[0_10px_40px_rgba(0,0,0,0.6)]" data-category="drafts">
                        <div class="relative aspect-[9/16] bg-black/80 overflow-hidden cursor-pointer play-trigger">
                            <img src="https://images.unsplash.com/photo-1720962158789-9389a4f399da?w=800&amp;q=80" alt="Thumbnail" class="absolute inset-0 w-full h-full object-cover opacity-50 group-hover:opacity-80 transition-opacity duration-500 group-hover:scale-105 transform">
                            <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                <div class="w-14 h-14 bg-black/40 backdrop-blur-md rounded-full flex items-center justify-center border border-white/20 hover:scale-110 transition-transform">
                                    <iconify-icon icon="solar:play-bold" class="text-white text-2xl translate-x-[2px]" width="24" height="24"></iconify-icon>
                                </div>
                            </div>
                            <div class="absolute top-3 left-3 bg-white/20 backdrop-blur-md text-white border border-white/10 text-xs font-semibold tracking-wide uppercase px-2 py-1 rounded flex items-center gap-1">
                                Draft
                            </div>
                            <div class="absolute bottom-3 right-3 bg-black/80 backdrop-blur-sm text-white/90 text-xs px-1.5 py-0.5 rounded border border-white/10 font-mono">0:30</div>
                        </div>
                        <div class="p-4 border-t border-white/5">
                            <h3 class="font-display font-medium text-sm text-white/90 line-clamp-2 leading-snug mb-4 group-hover:text-accent transition-colors clip-title">The hidden cost of immersive reality</h3>
                            <div class="flex items-center justify-between">
                                <span class="text-xs text-white/40 uppercase tracking-wider">Hook: Cost</span>
                                <div class="flex gap-2">
                                    <button class="edit-btn w-8 h-8 flex items-center justify-center rounded-lg bg-white/5 hover:bg-white/15 border border-white/10 text-white/70 hover:text-white transition-colors" title="Edit">
                                        <iconify-icon icon="solar:pen-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                    <button class="w-8 h-8 flex items-center justify-center rounded-lg bg-white/5 hover:bg-white/15 border border-white/10 text-white/70 hover:text-white transition-colors" title="Export">
                                        <iconify-icon icon="solar:download-minimalistic-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                     <!-- Generation Loading Card (Dynamic) -->
                    <div id="processingCard" class="hidden relative bg-white/[0.01] border border-dashed border-white/20 rounded-xl overflow-hidden backdrop-blur-sm flex flex-col items-center justify-center min-h-[300px]">
                        <div class="relative w-16 h-16 mb-4">
                            <svg class="animate-spin text-accent/20 w-full h-full" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                                <path class="opacity-75 text-accent" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <iconify-icon icon="solar:cpu-bold-duotone" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-accent text-xl" width="24" height="24"></iconify-icon>
                        </div>
                        <span class="text-sm font-medium text-white/70 font-display">Processing...</span>
                        <span class="text-xs text-white/40 mt-1">Finding more hooks</span>
                    </div>
                </div>
            </section>

            <!-- 3. Active Editor Workspace (Hidden until edited) -->
            <section id="editorSection" class="hidden opacity-0 transition-opacity duration-500 pt-16 border-t border-white/10 mt-8">
                <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-8 gap-4">
                    <div>
                        <div class="text-accent text-xs font-medium tracking-widest uppercase mb-2 flex items-center gap-2">
                            <iconify-icon icon="solar:video-frame-linear" width="14" height="14"></iconify-icon> Advanced Editor
                        </div>
                        <h2 id="editorTitle" class="font-display text-2xl sm:text-3xl font-semibold tracking-tight text-white line-clamp-1">Select a clip to edit</h2>
                        <div class="mt-4 flex flex-wrap gap-3">
                            <label class="text-xs text-white/70 flex items-center gap-2">
                                Start
                                <input id="clipStartInput" type="number" min="0" step="0.1" class="w-24 bg-black/60 border border-white/15 rounded-lg px-2 py-1 text-white text-xs outline-none focus:border-accent/50">
                            </label>
                            <label class="text-xs text-white/70 flex items-center gap-2">
                                End
                                <input id="clipEndInput" type="number" min="0" step="0.1" class="w-24 bg-black/60 border border-white/15 rounded-lg px-2 py-1 text-white text-xs outline-none focus:border-accent/50">
                            </label>
                            <span id="clipDurationLabel" class="text-xs text-white/50 self-center"></span>
                        </div>
                        <p id="editorStatus" class="text-xs text-white/50 mt-2 min-h-[1.1rem]"></p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="openTimelineBtn" class="px-4 py-2.5 rounded-xl font-medium text-xs border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors flex items-center gap-2">
                            <iconify-icon icon="solar:video-frame-cut-2-linear" width="16" height="16"></iconify-icon>
                            Timeline+
                        </button>
                        <button id="renderBtn" class="bg-white text-bg px-6 py-2.5 rounded-xl font-medium text-sm hover:bg-gray-200 transition-colors flex items-center gap-2 shadow-lg min-w-[150px] justify-center">
                            <iconify-icon icon="solar:export-linear" width="18" height="18"></iconify-icon> <span>Render Video</span>
                        </button>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 h-auto lg:h-[700px]">
                    
                    <!-- Left: Video Preview -->
                    <div class="lg:col-span-5 xl:col-span-4 bg-black/40 border border-white/10 rounded-2xl p-4 flex flex-col items-center justify-center relative overflow-hidden backdrop-blur-md">
                        <div class="absolute inset-0 opacity-20 pointer-events-none" style="background-image: url('data:image/svg+xml,%3Csvg viewBox=\'0 0 256 256\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cfilter id=\'n\'%3E%3CfeTurbulence type=\'fractalNoise\' baseFrequency=\'0.9\' numOctaves=\'4\' stitchTiles=\'stitch\'/%3E%3C/filter%3E%3Crect width=\'100%25\' height=\'100%25\' filter=\'url(%23n)\'/%3E%3C/svg%3E')"></div>

                        <div class="w-full max-w-[320px] aspect-[9/16] bg-black rounded-xl border border-white/15 relative overflow-hidden shadow-2xl z-10 group">
                            <video id="editorVideo" class="absolute inset-0 w-full h-full object-cover opacity-80 transition-opacity" playsinline preload="metadata"></video>
                            <div id="editorYoutubeWrap" class="absolute inset-0 hidden bg-black">
                                <div id="editorYoutubePlayer" class="w-full h-full"></div>
                            </div>
                            <div id="editorYoutubeBlockedWrap" class="absolute inset-0 hidden items-center justify-center p-5 bg-black/90">
                                <div class="rounded-xl border border-white/10 bg-black/70 px-4 py-4 text-center">
                                    <div class="w-10 h-10 rounded-full mx-auto mb-3 bg-white/5 border border-white/10 flex items-center justify-center text-white/70">
                                        <iconify-icon icon="solar:video-frame-cut-2-linear" width="18" height="18"></iconify-icon>
                                    </div>
                                    <p id="editorYoutubeBlockedText" class="text-xs text-white/70 leading-relaxed">
                                        Este vídeo não permite preview incorporado. Você ainda pode editar cortes, legendas e gerar pack.
                                    </p>
                                </div>
                            </div>

                            <div id="captionPreviewOverlay" class="absolute inset-0 flex items-end justify-center px-4 pb-8 pointer-events-none">
                                <div id="captionPreviewText" class="text-center max-w-[92%] leading-tight font-semibold text-white drop-shadow-[0_3px_16px_rgba(0,0,0,0.9)]">
                                    Your caption will appear here.
                                </div>
                            </div>
                            <div id="clipOverlayLayer" class="absolute inset-0 pointer-events-none z-[12]"></div>

                            <div class="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/90 via-black/50 to-transparent">
                                <div class="h-1.5 bg-white/20 rounded-full mb-4 cursor-pointer relative overflow-hidden" id="videoProgress">
                                    <div class="absolute top-0 left-0 h-full bg-accent w-[45%] rounded-full shadow-[0_0_10px_rgba(200,255,0,0.8)]" id="videoProgressBar"></div>
                                </div>
                                <div class="flex justify-between items-center text-white">
                                    <button id="mainPlayBtn" class="hover:text-accent transition-colors w-8 h-8 flex items-center justify-center bg-white/10 rounded-full backdrop-blur-sm"><iconify-icon icon="solar:play-bold" width="16" height="16" id="mainPlayIcon" class="translate-x-[1px]"></iconify-icon></button>
                                    <span class="text-xs font-mono tracking-wider opacity-70" id="videoTime">0:26 / 0:58</span>
                                    <button class="hover:text-accent transition-colors"><iconify-icon icon="solar:maximize-linear" width="18" height="18"></iconify-icon></button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right: Editor Tools -->
                    <div class="lg:col-span-7 xl:col-span-8 bg-white/[0.02] border border-white/10 rounded-2xl flex flex-col overflow-hidden backdrop-blur-md relative">
                        <div class="flex border-b border-white/10 px-2 sm:px-6 bg-black/40 overflow-x-auto">
                            <button id="editorTabCaptions" data-editor-tab="captions" class="editor-tab-btn px-4 py-4 text-sm font-medium text-accent border-b-2 border-accent flex items-center gap-2 whitespace-nowrap">
                                <iconify-icon icon="solar:text-field-linear" width="18" height="18"></iconify-icon> <span class="hidden sm:inline">Captions</span>
                            </button>
                            <button id="editorTabAudio" data-editor-tab="audio" class="editor-tab-btn px-4 py-4 text-sm font-medium text-white/50 hover:text-white transition-colors flex items-center gap-2 whitespace-nowrap">
                                <iconify-icon icon="solar:music-note-2-linear" width="18" height="18"></iconify-icon> <span class="hidden sm:inline">Audio</span>
                            </button>
                            <button id="editorTabStyles" data-editor-tab="styles" class="editor-tab-btn px-4 py-4 text-sm font-medium text-white/50 hover:text-white transition-colors flex items-center gap-2 whitespace-nowrap">
                                <iconify-icon icon="solar:pallete-2-linear" width="18" height="18"></iconify-icon> <span class="hidden sm:inline">Styles</span>
                            </button>
                            <button id="editorTabComplement" data-editor-tab="complement" class="editor-tab-btn px-4 py-4 text-sm font-medium text-white/50 hover:text-white transition-colors flex items-center gap-2 whitespace-nowrap">
                                <iconify-icon icon="solar:gallery-add-linear" width="18" height="18"></iconify-icon> <span class="hidden sm:inline">Complementar Vídeo</span>
                            </button>
                        </div>

                        <div class="flex-grow flex flex-col xl:flex-row overflow-hidden">
                            <div class="w-full xl:w-2/3 flex flex-col border-r border-white/5 h-full">
                                <div class="p-4 border-b border-white/5 flex items-center justify-between bg-black/20">
                                    <div class="flex items-center gap-4">
                                        <label class="flex items-center gap-2 cursor-pointer group">
                                            <div class="relative flex items-center">
                                                <input type="checkbox" class="sr-only peer" checked="">
                                                <div class="w-9 h-5 bg-black border border-white/20 rounded-full peer peer-checked:bg-accent/20 peer-checked:border-accent/50 transition-all"></div>
                                                <div class="absolute left-1 w-3 h-3 bg-white rounded-full transition-all peer-checked:translate-x-4 peer-checked:bg-accent shadow-sm"></div>
                                            </div>
                                            <span class="text-xs text-white/70 font-medium group-hover:text-white transition-colors">Auto-Emoji</span>
                                        </label>
                                        <div class="h-4 w-[1px] bg-white/10"></div>
                                        <label class="flex items-center gap-2 cursor-pointer group">
                                            <div class="relative flex items-center">
                                                <input type="checkbox" class="sr-only peer" checked="">
                                                <div class="w-9 h-5 bg-black border border-white/20 rounded-full peer peer-checked:bg-accent/20 peer-checked:border-accent/50 transition-all"></div>
                                                <div class="absolute left-1 w-3 h-3 bg-white rounded-full transition-all peer-checked:translate-x-4 peer-checked:bg-accent shadow-sm"></div>
                                            </div>
                                            <span class="text-xs text-white/70 font-medium group-hover:text-white transition-colors">B-Roll</span>
                                        </label>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <button id="transcribeCaptionsBtn" class="text-xs text-accent border border-accent/30 hover:bg-accent hover:text-bg px-3 py-1.5 rounded transition-colors flex items-center gap-1 font-medium">
                                            <iconify-icon icon="solar:document-text-linear"></iconify-icon> Reajustar
                                        </button>
                                        <button class="text-xs text-accent border border-accent/30 hover:bg-accent hover:text-bg px-3 py-1.5 rounded transition-colors flex items-center gap-1 font-medium">
                                            <iconify-icon icon="solar:magic-stick-3-linear"></iconify-icon> AI Polish
                                        </button>
                                    </div>
                                </div>
                                <div class="px-4 py-2 border-b border-white/5 bg-black/30">
                                    <p id="transcribeStatus" class="text-xs text-white/50 min-h-[1rem]">
                                        Envie um link para transcrição automática. Use Reajustar para atualizar cortes e legendas.
                                    </p>
                                </div>
                                <div class="px-4 py-2 border-b border-white/5 bg-black/20">
                                    <details>
                                        <summary class="text-[11px] text-white/55 cursor-pointer hover:text-white transition-colors">YouTube cookies (opcional para vídeos com bot-check)</summary>
                                        <div class="mt-2 space-y-2">
                                            <textarea id="youtubeCookiesInput" rows="3" placeholder="Cole cookies do YouTube (Netscape cookies.txt, JSON exportado ou header Cookie)." class="w-full bg-black/60 border border-white/15 rounded-lg px-2 py-2 text-white/80 text-[11px] font-mono outline-none focus:border-accent/50"></textarea>
                                            <div class="flex items-center gap-2">
                                                <button id="saveYoutubeCookiesBtn" class="text-[11px] px-2.5 py-1.5 rounded border border-accent/35 text-accent hover:bg-accent hover:text-bg transition-colors">Salvar local</button>
                                                <button id="clearYoutubeCookiesBtn" class="text-[11px] px-2.5 py-1.5 rounded border border-white/20 text-white/70 hover:border-white/40 hover:text-white transition-colors">Limpar</button>
                                                <span id="youtubeCookiesStatus" class="text-[11px] text-white/40">Salvo apenas neste navegador.</span>
                                            </div>
                                        </div>
                                    </details>
                                </div>

                                <div class="p-4 overflow-y-auto space-y-3 custom-scrollbar flex-grow" id="captionList">
                                    <div class="flex gap-3 p-3 rounded-xl border border-white/5 bg-white/[0.01] hover:bg-white/[0.03] transition-colors group cursor-text">
                                        <div class="text-xs text-white/40 font-mono mt-2 w-10 text-right">0:21</div>
                                        <div class="flex-grow">
                                            <textarea class="w-full bg-transparent text-white/60 text-sm resize-none outline-none font-medium leading-relaxed" rows="2">Because standard monitors</textarea>
                                        </div>
                                    </div>
                                    
                                    <div class="flex gap-3 p-3 rounded-xl border border-accent/40 bg-accent/[0.05] group relative overflow-hidden shadow-[0_0_15px_rgba(200,255,0,0.05)] cursor-text">
                                        <div class="absolute left-0 top-0 bottom-0 w-[3px] bg-accent shadow-[0_0_8px_rgba(200,255,0,0.8)]"></div>
                                        <div class="text-xs text-accent font-mono mt-2 w-10 text-right">0:24</div>
                                        <div class="flex-grow">
                                            <textarea class="w-full bg-transparent text-white text-sm resize-none outline-none font-medium leading-relaxed selection:bg-accent/30" rows="2">are severely limiting our spatial computing</textarea>
                                            <div class="flex items-center gap-2 mt-2 pt-2 border-t border-white/10 opacity-100 transition-opacity">
                                                <button class="text-xs text-white/50 hover:text-white flex items-center gap-1"><iconify-icon icon="solar:text-bold"></iconify-icon> Highlight</button>
                                                <button class="text-xs text-white/50 hover:text-white flex items-center gap-1"><iconify-icon icon="solar:gallery-bold"></iconify-icon> Add B-Roll</button>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex gap-3 p-3 rounded-xl border border-white/5 bg-white/[0.01] hover:bg-white/[0.03] transition-colors group cursor-text">
                                        <div class="text-xs text-white/40 font-mono mt-2 w-10 text-right">0:28</div>
                                        <div class="flex-grow">
                                            <textarea class="w-full bg-transparent text-white/60 text-sm resize-none outline-none font-medium leading-relaxed" rows="2">potential in the near future. 🚀</textarea>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="w-full xl:w-1/3 bg-black/20 flex flex-col h-full border-t xl:border-t-0 border-white/5 overflow-y-auto custom-scrollbar">
                                <div id="complementPanel" class="hidden p-4 border-b border-white/5">
                                    <h4 class="text-xs font-semibold text-white/40 uppercase tracking-widest mb-3">Complementar Vídeo (AI Fill)</h4>
                                    <div class="grid grid-cols-1 gap-2 mb-2">
                                        <label class="text-[11px] text-white/60 space-y-1">
                                            Provider
                                            <select id="complementProviderSelect" class="w-full bg-black/60 border border-white/15 rounded px-2 py-1.5 text-white text-xs">
                                                <option value="openai">OpenAI Images</option>
                                            </select>
                                        </label>
                                        <label class="text-[11px] text-white/60 space-y-1">
                                            API Key (salva localmente)
                                            <input id="complementApiKeyInput" type="password" placeholder="sk-..." class="w-full bg-black/60 border border-white/15 rounded px-3 py-2 text-white text-xs outline-none focus:border-accent/50">
                                        </label>
                                        <div class="flex gap-2">
                                            <button id="complementSaveKeyBtn" class="flex-1 text-xs px-2 py-2 rounded-lg border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Salvar Key</button>
                                            <button id="complementClearKeyBtn" class="text-xs px-2 py-2 rounded-lg border border-white/20 text-white/70 hover:border-white/40 hover:text-white transition-colors">Limpar</button>
                                        </div>
                                        <p id="complementStatus" class="text-[11px] text-white/40 min-h-[1rem]">Defina a key e peça para gerar imagens de preenchimento.</p>
                                    </div>

                                    <div id="complementChatLog" class="h-24 overflow-y-auto custom-scrollbar rounded-lg border border-white/10 bg-black/30 p-3 space-y-2 text-xs mb-2"></div>
                                    <div class="flex gap-2 mb-2">
                                        <input id="complementChatInput" type="text" placeholder="Ex: gerar imagem cinematográfica da fala atual" class="flex-grow bg-black/60 border border-white/15 rounded-lg px-3 py-2 text-white text-xs outline-none focus:border-accent/50">
                                        <button id="complementChatSendBtn" class="px-3 py-2 text-xs rounded-lg bg-accent text-bg font-medium hover:brightness-110 transition-all">Send</button>
                                    </div>
                                    <div class="flex gap-2 mb-2">
                                        <button id="complementAutoFillBtn" class="flex-1 text-xs px-2 py-2 rounded-lg bg-white/5 border border-white/10 hover:border-accent/40 hover:text-accent transition-colors">Gerar para gaps</button>
                                        <button id="complementRegenerateBtn" class="text-xs px-2 py-2 rounded-lg border border-white/20 text-white/70 hover:border-white/40 hover:text-white transition-colors">Regenerar</button>
                                    </div>
                                    <div id="complementImageList" class="space-y-2 text-xs text-white/70"></div>
                                </div>

                                <div id="captionStyleSection" class="editor-main-panel p-4 border-b border-white/5">
                                    <h4 class="text-xs font-semibold text-white/40 uppercase tracking-widest mb-4">Caption Style</h4>
                                    <div class="grid grid-cols-2 gap-2 mb-3">
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Font
                                            <select id="captionFontFamilySelect" class="w-full bg-black/60 border border-white/15 rounded px-2 py-1.5 text-white text-xs">
                                                <option value="body">Space Grotesk</option>
                                                <option value="display">Syne</option>
                                                <option value="mono">JetBrains Mono</option>
                                            </select>
                                        </label>
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Weight
                                            <select id="captionWeightSelect" class="w-full bg-black/60 border border-white/15 rounded px-2 py-1.5 text-white text-xs">
                                                <option value="500">Medium</option>
                                                <option value="700" selected="">Bold</option>
                                                <option value="900">Black</option>
                                            </select>
                                        </label>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2 mb-3">
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Text
                                            <input id="captionTextColorInput" type="color" value="#ffffff" class="w-full h-8 bg-transparent border border-white/15 rounded p-1">
                                        </label>
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            BG
                                            <input id="captionBgColorInput" type="color" value="#000000" class="w-full h-8 bg-transparent border border-white/15 rounded p-1">
                                        </label>
                                    </div>
                                    <div class="space-y-2 mb-3">
                                        <label class="text-[11px] text-white/70 flex items-center justify-between gap-2">
                                            Size
                                            <span id="captionSizeValue" class="text-white/40">38px</span>
                                        </label>
                                        <input id="captionFontSizeInput" type="range" min="20" max="72" value="38" class="custom-range w-full h-1 bg-white/10 rounded-full appearance-none outline-none" style="background: linear-gradient(to right, #c8ff00 34%, rgba(255,255,255,0.1) 34%);">
                                    </div>
                                    <div class="space-y-2 mb-3">
                                        <label class="text-[11px] text-white/70 flex items-center justify-between gap-2">
                                            BG Opacity
                                            <span id="captionBgOpacityValue" class="text-white/40">52%</span>
                                        </label>
                                        <input id="captionBgOpacityInput" type="range" min="0" max="100" value="52" class="custom-range w-full h-1 bg-white/10 rounded-full appearance-none outline-none" style="background: linear-gradient(to right, #c8ff00 52%, rgba(255,255,255,0.1) 52%);">
                                    </div>
                                    <div class="grid grid-cols-2 gap-2 mb-3">
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Position
                                            <select id="captionPositionSelect" class="w-full bg-black/60 border border-white/15 rounded px-2 py-1.5 text-white text-xs">
                                                <option value="top">Top</option>
                                                <option value="middle">Middle</option>
                                                <option value="bottom" selected="">Bottom</option>
                                            </select>
                                        </label>
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Case
                                            <select id="captionCaseSelect" class="w-full bg-black/60 border border-white/15 rounded px-2 py-1.5 text-white text-xs">
                                                <option value="normal" selected="">Normal</option>
                                                <option value="uppercase">UPPER</option>
                                                <option value="lowercase">lower</option>
                                            </select>
                                        </label>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Stroke Color
                                            <input id="captionStrokeColorInput" type="color" value="#000000" class="w-full h-8 bg-transparent border border-white/15 rounded p-1">
                                        </label>
                                        <label class="text-[11px] text-white/70 space-y-1">
                                            Stroke
                                            <input id="captionStrokeSizeInput" type="number" min="0" max="8" value="2" class="w-full bg-black/60 border border-white/15 rounded px-2 py-1.5 text-white text-xs">
                                        </label>
                                    </div>
                                </div>

                                <div id="audioMixSection" class="editor-main-panel p-4 border-b border-white/5">
                                    <h4 class="text-xs font-semibold text-white/40 uppercase tracking-widest mb-4">Audio Mix</h4>
                                    <div class="bg-white/[0.02] border border-white/5 rounded-xl p-3 mb-3">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="text-xs text-white/80">Background Music</span>
                                            <span class="text-xs text-white/40" id="musicVolumeLabel">15%</span>
                                        </div>
                                        <input id="musicVolumeInput" type="range" min="0" max="100" value="15" class="custom-range w-full h-1 bg-white/10 rounded-full appearance-none outline-none" style="background: linear-gradient(to right, #c8ff00 15%, rgba(255,255,255,0.1) 15%);">
                                    </div>
                                    <div class="bg-white/[0.02] border border-white/5 rounded-xl p-3">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="text-xs text-white/80">Voice Volume</span>
                                            <span class="text-xs text-white/40" id="voiceVolumeLabel">100%</span>
                                        </div>
                                        <input id="voiceVolumeInput" type="range" min="0" max="100" value="100" data-color="#ffffff" class="custom-range w-full h-1 bg-white/10 rounded-full appearance-none outline-none" style="background: linear-gradient(to right, #fff 100%, rgba(255,255,255,0.1) 100%);">
                                    </div>
                                </div>

                                <div id="spaceHubSection" class="editor-main-panel p-4 border-b border-white/5">
                                    <h4 class="text-xs font-semibold text-white/40 uppercase tracking-widest mb-3">Space Hub</h4>
                                    <div class="flex gap-2 mb-2">
                                        <input id="spaceNameInput" type="text" placeholder="Nome do Automar Space" class="flex-grow bg-black/60 border border-white/15 rounded-lg px-3 py-2 text-white text-xs outline-none focus:border-accent/50">
                                        <button id="connectSpaceBtn" class="px-3 py-2 text-xs rounded-lg border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Open Space</button>
                                    </div>
                                    <p id="spaceStatus" class="text-xs text-white/50 min-h-[1rem] mb-3">Space desconectado.</p>
                                    <p class="text-[11px] text-white/40 mb-3">Abre um workspace visual para automações de vídeo (cuts, legendas, thumb, pack).</p>
                                    <div class="grid grid-cols-2 gap-2">
                                        <button id="generateThumbBtn" class="text-xs px-2 py-2 rounded-lg bg-white/5 border border-white/10 hover:border-accent/40 hover:text-accent transition-colors">Generate Thumb</button>
                                        <button id="generateTitlesBtn" class="text-xs px-2 py-2 rounded-lg bg-white/5 border border-white/10 hover:border-accent/40 hover:text-accent transition-colors">Generate Titles</button>
                                        <button id="generateHashtagsBtn" class="text-xs px-2 py-2 rounded-lg bg-white/5 border border-white/10 hover:border-accent/40 hover:text-accent transition-colors">Hashtags</button>
                                        <button id="downloadPackBtn" class="text-xs px-2 py-2 rounded-lg bg-accent/10 border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Download Pack</button>
                                    </div>
                                    <div id="spaceOutputs" class="mt-3 space-y-2 text-xs text-white/70"></div>
                                </div>

                                <div id="commandChatSection" class="editor-main-panel p-4">
                                    <h4 class="text-xs font-semibold text-white/40 uppercase tracking-widest mb-3">Command Chat + Voice</h4>
                                    <div class="flex items-center justify-between gap-2 mb-2">
                                        <span id="agentIdBadge" class="text-[11px] text-white/50 truncate">Agent: pending...</span>
                                        <button id="agentConnectBtn" class="text-[11px] px-2 py-1 rounded border border-white/15 hover:border-accent/40 hover:text-accent transition-colors">
                                            Connect Agent
                                        </button>
                                    </div>
                                    <p id="agentStatus" class="text-[11px] text-white/40 mb-2">Agent: disconnected</p>
                                    <div id="commandChatLog" class="h-36 overflow-y-auto custom-scrollbar rounded-lg border border-white/10 bg-black/30 p-3 space-y-2 text-xs"></div>
                                    <div class="mt-2 flex gap-2">
                                        <input id="commandInput" type="text" placeholder="Ex: uppercase captions, trim end -2, abrir automar, timeline, crop zoom 120, add text CTA..." class="flex-grow bg-black/60 border border-white/15 rounded-lg px-3 py-2 text-white text-xs outline-none focus:border-accent/50">
                                        <button id="commandMicBtn" class="w-10 h-10 rounded-lg border border-white/15 hover:border-accent/40 text-white/80 hover:text-accent transition-colors" title="Voice command">
                                            <iconify-icon icon="solar:microphone-3-linear" width="18" height="18"></iconify-icon>
                                        </button>
                                        <button id="commandSendBtn" class="px-3 py-2 text-xs rounded-lg bg-accent text-bg font-medium hover:brightness-110 transition-all">Run</button>
                                    </div>
                                    <p id="voiceStatus" class="text-[11px] text-white/40 mt-2">Voice: idle</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="mt-6 bg-white/[0.02] border border-white/10 rounded-xl p-4">
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 mb-2">
                        <h4 class="text-xs font-semibold text-white/40 uppercase tracking-widest">Comandos Rápidos</h4>
                        <span class="text-[11px] text-white/40">Dica: digite `ajuda` no chat para orientação dinâmica.</span>
                    </div>
                    <p class="text-xs text-white/60 mb-3">
                        Exemplos: "uppercase captions", "caption size 52", "caption color #c8ff00", "position top",
                        "trim end -3", "music 20", "voice 85", "conectar space campanha-q2", "abrir automar", "timeline",
                        "complementar", "gerar gaps", "fill: cena noturna com chuva", "crop zoom 120", "add text: call to action", "gerar thumb",
                        "gerar títulos", "gerar hashtags", "transcrever", "connect agent", "agent id: agent_xxx", "download pack".
                    </p>
                    <div id="commandShortcutBar" class="flex flex-wrap gap-2">
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="help">ajuda</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="clip 1">clip 1</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="transcrever">transcrever</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="uppercase captions">uppercase</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="caption size 48">caption 48px</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="position top">posição top</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="abrir automar">automar</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="timeline">timeline</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="complementar">complementar</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="gerar gaps">gaps</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="gerar thumb">thumb</button>
                        <button type="button" class="command-shortcut text-[11px] px-2.5 py-1.5 rounded-lg border border-white/15 text-white/70 hover:border-accent/40 hover:text-accent transition-colors" data-command="download pack">download pack</button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <div id="videoAutomationModal" class="hidden fixed inset-0 z-[220] items-center justify-center p-2 sm:p-5 bg-black/85 backdrop-blur-md">
        <div class="w-full max-w-[1520px] h-[94vh] rounded-2xl border border-white/10 bg-[#07090d] shadow-2xl overflow-hidden flex flex-col">
            <div class="px-4 sm:px-6 py-3 border-b border-white/10 bg-black/40 flex items-center justify-between">
                <div class="flex items-center gap-2 text-xs text-white/50">
                    <iconify-icon icon="solar:layers-linear" width="16" height="16"></iconify-icon>
                    <span>Workflows</span>
                    <span>/</span>
                    <span id="automationSpaceTitle" class="text-white font-medium">Automar Video Space</span>
                </div>
                <div class="flex items-center gap-2">
                    <button id="automationRunBtn" class="px-3 py-1.5 text-xs rounded-lg border border-white/20 text-white/80 hover:border-accent/40 hover:text-accent transition-colors">Test run</button>
                    <button id="automationDeployBtn" class="px-3 py-1.5 text-xs rounded-lg bg-accent text-bg font-semibold hover:brightness-110 transition-all">Deploy</button>
                    <button id="videoAutomationCloseBtn" class="w-8 h-8 rounded-lg border border-white/15 text-white/70 hover:text-white hover:border-white/30 transition-colors">
                        <iconify-icon icon="solar:close-circle-linear" width="18" height="18"></iconify-icon>
                    </button>
                </div>
            </div>

            <div class="flex-1 min-h-0 grid grid-cols-1 lg:grid-cols-12">
                <aside class="lg:col-span-2 border-r border-white/10 bg-black/35 p-4 flex flex-col gap-4">
                    <div class="text-lg font-display text-white flex items-center gap-2">
                        <iconify-icon icon="solar:box-linear" width="18" height="18" class="text-accent"></iconify-icon>
                        Automar
                    </div>
                    <div class="relative">
                        <input type="text" readonly value="video workflows" class="w-full text-xs bg-black/50 border border-white/10 rounded-lg px-3 py-2 text-white/60">
                    </div>
                    <div class="space-y-2 text-sm">
                        <button class="w-full text-left px-3 py-2 rounded-lg bg-white/5 border border-white/10 text-white/90">Overview</button>
                        <button class="w-full text-left px-3 py-2 rounded-lg bg-accent/10 border border-accent/30 text-accent">Workflows</button>
                        <button class="w-full text-left px-3 py-2 rounded-lg bg-white/[0.02] border border-white/10 text-white/70">Integrations</button>
                        <button class="w-full text-left px-3 py-2 rounded-lg bg-white/[0.02] border border-white/10 text-white/70">Settings</button>
                    </div>
                    <div class="mt-auto text-[11px] text-white/40">
                        <p>Conectado ao Space:</p>
                        <p id="automationSpaceFooterName" class="text-white/80 mt-1">-</p>
                    </div>
                </aside>

                <section class="lg:col-span-7 p-4 sm:p-6 border-r border-white/10 relative overflow-auto">
                    <div class="relative h-full min-h-[520px] rounded-xl border border-white/10 bg-[radial-gradient(circle_at_25%_15%,rgba(200,255,0,0.08),transparent_38%),radial-gradient(circle_at_85%_85%,rgba(29,78,216,0.16),transparent_42%),linear-gradient(to_bottom,#05070b,#020306)] overflow-hidden">
                        <svg class="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 1000 640" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="automarFlowLine" x1="0" x2="1">
                                    <stop offset="0%" stop-color="#4f596b" stop-opacity="0.45"></stop>
                                    <stop offset="100%" stop-color="#c8ff00" stop-opacity="0.9"></stop>
                                </linearGradient>
                            </defs>
                            <path d="M180 320 C300 320, 330 190, 460 190" stroke="url(#automarFlowLine)" stroke-width="3" fill="none"></path>
                            <path d="M180 320 C300 320, 330 440, 460 440" stroke="url(#automarFlowLine)" stroke-width="3" fill="none"></path>
                            <path d="M555 190 C680 190, 700 315, 790 315" stroke="url(#automarFlowLine)" stroke-width="3" fill="none"></path>
                            <path d="M555 440 C680 440, 700 325, 790 325" stroke="url(#automarFlowLine)" stroke-width="3" fill="none"></path>
                        </svg>

                        <button type="button" data-automar-node="trigger_new_video" class="automar-node absolute left-[6%] top-[40%] w-[200px] rounded-xl border border-accent/30 bg-black/70 px-4 py-3 text-left shadow-[0_0_18px_rgba(200,255,0,0.12)]">
                            <div class="text-[10px] uppercase tracking-widest text-accent">Trigger</div>
                            <div class="automar-node-title text-base text-white mt-1">New video ingested</div>
                            <div class="text-xs text-white/50 mt-2 automar-node-subtitle">Source: clip library</div>
                        </button>

                        <button type="button" data-automar-node="action_detect_cuts" class="automar-node absolute left-[44%] top-[17%] w-[220px] rounded-xl border border-white/20 bg-black/75 px-4 py-3 text-left">
                            <div class="text-[10px] uppercase tracking-widest text-white/60">Action</div>
                            <div class="automar-node-title text-base text-white mt-1">Detect best cuts</div>
                            <div class="text-xs text-white/50 mt-2 automar-node-subtitle">Score + timing map</div>
                        </button>

                        <button type="button" data-automar-node="action_captions" class="automar-node absolute left-[44%] top-[58%] w-[220px] rounded-xl border border-white/20 bg-black/75 px-4 py-3 text-left">
                            <div class="text-[10px] uppercase tracking-widest text-white/60">Action</div>
                            <div class="automar-node-title text-base text-white mt-1">Generate captions</div>
                            <div class="text-xs text-white/50 mt-2 automar-node-subtitle">Model: scribe_v1</div>
                        </button>

                        <button type="button" data-automar-node="logic_review_wait" class="automar-node absolute left-[76%] top-[36%] w-[180px] rounded-xl border border-white/20 bg-black/75 px-4 py-3 text-left">
                            <div class="text-[10px] uppercase tracking-widest text-white/60">Logic</div>
                            <div class="automar-node-title text-base text-white mt-1">Wait review</div>
                            <div class="text-xs text-white/50 mt-2 automar-node-subtitle">Duration: 10m</div>
                        </button>

                        <button type="button" data-automar-node="action_publish_pack" class="automar-node absolute left-[76%] top-[62%] w-[180px] rounded-xl border border-white/20 bg-black/75 px-4 py-3 text-left">
                            <div class="text-[10px] uppercase tracking-widest text-white/60">Action</div>
                            <div class="automar-node-title text-base text-white mt-1">Publish pack</div>
                            <div class="text-xs text-white/50 mt-2 automar-node-subtitle">Thumb + titles + hashtags</div>
                        </button>
                    </div>
                </section>

                <aside class="lg:col-span-3 p-4 sm:p-5 overflow-auto bg-black/25">
                    <h3 class="text-lg font-display text-white mb-1">Video automation</h3>
                    <p class="text-xs text-white/50 mb-4">Use IA instructions para ajustar o node selecionado.</p>

                    <div class="rounded-xl border border-white/10 bg-black/45 p-3 mb-4">
                        <p class="text-[10px] uppercase tracking-widest text-white/40 mb-2">AI Assistant</p>
                        <textarea id="automationPromptInput" rows="3" placeholder="Ex: deixe captions uppercase, espere 20m e gere thumbnail automática." class="w-full bg-black/50 border border-white/10 rounded-lg px-3 py-2 text-xs text-white outline-none focus:border-accent/50"></textarea>
                        <button id="automationApplyPromptBtn" class="mt-2 w-full px-3 py-2 text-xs rounded-lg bg-accent text-bg font-semibold hover:brightness-110 transition-all">Apply</button>
                        <p id="automationPromptStatus" class="text-[11px] text-white/40 mt-2 min-h-[1rem]"></p>
                    </div>

                    <div class="rounded-xl border border-white/10 bg-black/45 p-3 mb-4 space-y-2">
                        <div class="flex items-center justify-between gap-2">
                            <p class="text-[10px] uppercase tracking-widest text-white/40">Config</p>
                            <span id="automationNodeTypeBadge" class="text-[10px] px-2 py-1 rounded bg-white/10 text-white/70">ACTION</span>
                        </div>
                        <p id="automationSelectedNodeLabel" class="text-sm text-white font-medium">Node</p>
                        <label class="block text-[11px] text-white/60">Name
                            <input id="automationNodeNameInput" type="text" class="mt-1 w-full bg-black/50 border border-white/10 rounded px-2 py-1.5 text-xs text-white">
                        </label>
                        <label class="block text-[11px] text-white/60">Delay (minutes)
                            <input id="automationNodeDelayInput" type="number" min="0" max="1440" value="10" class="mt-1 w-full bg-black/50 border border-white/10 rounded px-2 py-1.5 text-xs text-white">
                        </label>
                        <label class="block text-[11px] text-white/60">Caption preset
                            <select id="automationNodePresetSelect" class="mt-1 w-full bg-black/50 border border-white/10 rounded px-2 py-1.5 text-xs text-white">
                                <option value="balanced">Balanced</option>
                                <option value="neon">Neon</option>
                                <option value="clean">Clean</option>
                                <option value="bold">Bold</option>
                            </select>
                        </label>
                        <label class="flex items-center justify-between text-[11px] text-white/70">
                            Auto thumb
                            <input id="automationNodeAutoThumb" type="checkbox" class="accent-lime-400">
                        </label>
                        <label class="flex items-center justify-between text-[11px] text-white/70">
                            Auto hashtags
                            <input id="automationNodeAutoHashtags" type="checkbox" class="accent-lime-400">
                        </label>
                        <button id="automationNodeSaveBtn" class="w-full mt-1 px-3 py-2 text-xs rounded-lg border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Save node config</button>
                    </div>

                    <div class="rounded-xl border border-white/10 bg-black/45 p-3">
                        <p class="text-[10px] uppercase tracking-widest text-white/40 mb-2">Flow health</p>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div class="rounded-lg border border-white/10 p-2 text-center">
                                <p class="text-white/40">Nodes</p>
                                <p class="text-white font-semibold" id="automationNodesCount">5</p>
                            </div>
                            <div class="rounded-lg border border-white/10 p-2 text-center">
                                <p class="text-white/40">Success</p>
                                <p class="text-accent font-semibold" id="automationSuccessRate">99.1%</p>
                            </div>
                        </div>
                    </div>

                    <div class="rounded-xl border border-white/10 bg-black/45 p-3 mt-4 space-y-2">
                        <p class="text-[10px] uppercase tracking-widest text-white/40">AI Infrastructure</p>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="automationIngestBtn" class="px-3 py-2 text-xs rounded-lg border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Run ingest</button>
                            <button id="automationLoadTemplatesBtn" class="px-3 py-2 text-xs rounded-lg border border-white/20 text-white/80 hover:border-accent/40 hover:text-accent transition-colors">Templates</button>
                        </div>
                        <label class="block text-[11px] text-white/60">Patch timestamp (s)
                            <input id="automationPatchTimestampInput" type="number" min="0" step="0.1" value="0" class="mt-1 w-full bg-black/50 border border-white/10 rounded px-2 py-1.5 text-xs text-white">
                        </label>
                        <label class="block text-[11px] text-white/60">Patch instruction
                            <textarea id="automationPatchInstructionInput" rows="2" placeholder="Ex: trocar produto na mão por novo modelo." class="mt-1 w-full bg-black/50 border border-white/10 rounded px-2 py-1.5 text-xs text-white outline-none focus:border-accent/50"></textarea>
                        </label>
                        <label class="block text-[11px] text-white/60">Provider
                            <select id="automationPatchProviderSelect" class="mt-1 w-full bg-black/50 border border-white/10 rounded px-2 py-1.5 text-xs text-white">
                                <option value="google_nano_banana">Google Nano Banana</option>
                                <option value="kling">Kling 3.0</option>
                                <option value="veo">Veo</option>
                            </select>
                        </label>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="automationCreatePatchBtn" class="px-3 py-2 text-xs rounded-lg border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Create patch</button>
                            <button id="automationExecutePatchBtn" class="px-3 py-2 text-xs rounded-lg border border-white/20 text-white/80 hover:border-accent/40 hover:text-accent transition-colors">Execute patch</button>
                            <button id="automationPlanRenderBtn" class="px-3 py-2 text-xs rounded-lg border border-white/20 text-white/80 hover:border-accent/40 hover:text-accent transition-colors">Plan render</button>
                            <button id="automationExecuteRenderBtn" class="px-3 py-2 text-xs rounded-lg border border-accent/20 text-accent/90 hover:bg-accent hover:text-bg transition-colors">Execute render</button>
                        </div>
                        <p id="automationInfraStatus" class="text-[11px] text-white/40 min-h-[1rem]">Pronto para ingest/frame patch/render incremental.</p>
                        <div id="automationInfraLog" class="max-h-[128px] overflow-auto custom-scrollbar rounded-lg border border-white/10 bg-black/35 p-2 space-y-1 text-[11px] text-white/70"></div>
                    </div>
                </aside>
            </div>
        </div>
    </div>

    <div id="timelineModal" class="hidden fixed inset-0 z-[230] items-center justify-center p-3 sm:p-6 bg-black/90 backdrop-blur-md">
        <div class="timeline-shell w-full max-w-[1380px] rounded-[28px] border border-lime-300/20 overflow-hidden">
            <div class="timeline-shell-inner p-3 sm:p-4">
                <div class="timeline-glass rounded-2xl px-3 py-2.5 sm:px-4 sm:py-3 flex flex-wrap items-center justify-between gap-2">
                    <div class="flex items-center gap-2 sm:gap-3 min-w-0">
                        <span class="timeline-badge">
                            <iconify-icon icon="solar:video-library-line-duotone" width="13" height="13"></iconify-icon>
                            Advanced Editor
                        </span>
                        <h3 id="timelineClipTitle" class="text-base sm:text-[1.35rem] text-white tracking-tight truncate">Project Timeline</h3>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="timelineOpenEditorBtn" class="timeline-chip-btn px-3 py-2 rounded-xl text-[12px] font-semibold transition-colors flex items-center gap-1.5">
                            <iconify-icon icon="solar:add-square-linear" width="15" height="15"></iconify-icon>
                            Timeline +
                        </button>
                        <button id="timelinePlayBtn" class="timeline-white-btn px-3.5 py-2 rounded-xl text-[12px] font-semibold transition-transform hover:scale-[1.03] flex items-center gap-1.5">
                            <iconify-icon icon="solar:play-line-duotone" width="15" height="15"></iconify-icon>
                            Play / Pause
                        </button>
                        <button id="timelineCloseBtn" class="w-9 h-9 rounded-xl border border-white/20 text-white/75 hover:text-white hover:border-white/45 transition-colors flex items-center justify-center">
                            <iconify-icon icon="solar:close-circle-linear" width="19" height="19"></iconify-icon>
                        </button>
                    </div>
                </div>

                <div class="mt-3 timeline-glass rounded-2xl px-3 py-2 sm:px-4 sm:py-3">
                    <div class="flex flex-wrap items-center gap-3 sm:gap-4 text-[11px] sm:text-[12px]">
                        <div class="flex items-center gap-1.5 text-white/70">
                            <span class="timeline-soft-label">Start</span>
                            <span id="timelineStartValue" class="font-mono text-white px-2 py-1 rounded-md border border-white/15 bg-black/35">0:00</span>
                        </div>
                        <div class="flex items-center gap-1.5 text-white/70">
                            <span class="timeline-soft-label">Playhead</span>
                            <span id="timelinePlayheadValue" class="font-mono text-accent px-2 py-1 rounded-md border border-accent/30 bg-accent/10">0:00</span>
                        </div>
                        <div class="flex items-center gap-1.5 text-white/70">
                            <span class="timeline-soft-label">End</span>
                            <span id="timelineEndValue" class="font-mono text-white px-2 py-1 rounded-md border border-white/15 bg-black/35">0:00</span>
                        </div>
                        <div class="flex items-center gap-1.5 text-white/70">
                            <span class="timeline-soft-label">Duration</span>
                            <span id="timelineDurationValue" class="font-mono text-white/90 px-2 py-1 rounded-md border border-white/15 bg-black/35">0:00</span>
                        </div>
                        <span id="timelineStatus" class="text-white/40 min-h-[1rem]"></span>
                    </div>
                </div>

                <div class="mt-3 grid grid-cols-1 xl:grid-cols-12 gap-3 sm:gap-4">
                    <div class="xl:col-span-9 timeline-glass rounded-2xl p-3 sm:p-4">
                        <div class="timeline-ruler">
                            <span>00:00</span>
                            <span>00:10</span>
                            <span>00:20</span>
                            <span>00:30</span>
                            <span>00:40</span>
                            <span>00:50</span>
                        </div>

                        <div class="timeline-track-grid">
                            <div id="timelinePlayheadNeedle" class="timeline-playhead">
                                <span id="timelinePlayheadTag" class="timeline-playhead-tag">0:00</span>
                            </div>

                            <div class="timeline-track-row">
                                <div class="timeline-track-label">
                                    <iconify-icon icon="solar:video-frame-play-horizontal-linear" width="14" height="14"></iconify-icon>
                                    V1
                                </div>
                                <div class="timeline-row-lane">
                                    <div class="timeline-clip-pill" style="left:2%; width:46%;">Main Clip 01</div>
                                    <div class="timeline-clip-pill" style="left:49%; width:40%;">Main Clip 02</div>
                                </div>
                            </div>

                            <div class="timeline-track-row">
                                <div class="timeline-track-label">
                                    <iconify-icon icon="solar:video-frame-play-horizontal-linear" width="14" height="14"></iconify-icon>
                                    V2
                                </div>
                                <div class="timeline-row-lane">
                                    <div class="timeline-clip-pill blue" style="left:2%; width:34%;">B-Roll Clip 1</div>
                                    <div class="timeline-clip-pill" style="left:37%; width:27%;">B-Roll Clip 1B</div>
                                    <div class="timeline-wave"></div>
                                </div>
                            </div>

                            <div class="timeline-track-row">
                                <div class="timeline-track-label">
                                    <iconify-icon icon="solar:music-note-2-line-duotone" width="14" height="14"></iconify-icon>
                                    Audio 1
                                </div>
                                <div class="timeline-row-lane">
                                    <div class="timeline-clip-pill purple" style="left:2%; width:43%;">Voiceover 01</div>
                                    <div class="timeline-clip-pill purple" style="left:47%; width:43%;">Background Music</div>
                                </div>
                            </div>

                            <div class="timeline-track-row">
                                <div class="timeline-track-label">
                                    <iconify-icon icon="solar:soundwave-linear" width="14" height="14"></iconify-icon>
                                    SFX
                                </div>
                                <div class="timeline-row-lane">
                                    <div class="timeline-clip-pill blue" style="left:4%; width:30%;">Sound FX Clip</div>
                                    <div class="timeline-clip-pill blue" style="left:58%; width:28%;">Impact FX</div>
                                </div>
                            </div>
                        </div>

                        <div class="mt-3">
                            <input id="timelineScrubber" type="range" min="0" max="1000" value="0" class="custom-range w-full h-1.5 bg-white/10 rounded-full appearance-none outline-none">
                        </div>

                        <div class="mt-3 grid grid-cols-2 sm:grid-cols-5 gap-2">
                            <button id="timelineSetInBtn" class="px-3 py-2 text-xs rounded-lg border border-accent/35 text-accent hover:bg-accent hover:text-bg transition-colors">Set IN</button>
                            <button id="timelineSetOutBtn" class="px-3 py-2 text-xs rounded-lg border border-accent/35 text-accent hover:bg-accent hover:text-bg transition-colors">Set OUT</button>
                            <button id="timelineCutLeftBtn" class="px-3 py-2 text-xs rounded-lg border border-white/25 text-white/80 hover:border-white/40 hover:text-white transition-colors">Cut Left</button>
                            <button id="timelineCutRightBtn" class="px-3 py-2 text-xs rounded-lg border border-white/25 text-white/80 hover:border-white/40 hover:text-white transition-colors">Cut Right</button>
                            <button id="timelineResetBtn" class="px-3 py-2 text-xs rounded-lg border border-white/25 text-white/80 hover:border-white/40 hover:text-white transition-colors">Reset Cut</button>
                        </div>
                    </div>

                    <aside class="xl:col-span-3 timeline-side-panel p-3 sm:p-4">
                        <div class="timeline-tab-strip">
                            <span class="timeline-tab active">Captions</span>
                            <span class="timeline-tab">Audio</span>
                            <span class="timeline-tab">Effects</span>
                            <span class="timeline-tab active">AI Polish</span>
                        </div>

                        <div class="space-y-2.5">
                            <div class="timeline-toggle">
                                <span>Transcribe</span>
                                <span class="timeline-toggle-dot" aria-hidden="true"></span>
                            </div>
                            <div class="timeline-toggle">
                                <span>Generate B-Roll</span>
                                <span class="timeline-toggle-dot" aria-hidden="true"></span>
                            </div>
                            <div class="timeline-toggle">
                                <span>Enhance Audio</span>
                                <span class="timeline-toggle-dot" aria-hidden="true"></span>
                            </div>
                            <div class="timeline-toggle">
                                <span>Auto Cut Silence</span>
                                <span class="timeline-toggle-dot" aria-hidden="true"></span>
                            </div>
                        </div>

                        <div class="mt-3 rounded-xl border border-white/10 bg-black/35 p-3">
                            <p class="text-xs text-white/70 mb-2">Crop</p>
                            <div class="space-y-2.5 text-[11px] text-white/60">
                                <label class="block">Zoom
                                    <input id="timelineCropZoom" type="range" min="100" max="180" value="100" class="custom-range mt-1.5 w-full h-1 bg-white/10 rounded-full appearance-none outline-none">
                                    <span id="timelineCropZoomValue" class="text-white/70">100%</span>
                                </label>
                                <label class="block">X Offset
                                    <input id="timelineCropX" type="range" min="-40" max="40" value="0" class="custom-range mt-1.5 w-full h-1 bg-white/10 rounded-full appearance-none outline-none">
                                    <span id="timelineCropXValue" class="text-white/70">0%</span>
                                </label>
                                <label class="block">Y Offset
                                    <input id="timelineCropY" type="range" min="-40" max="40" value="0" class="custom-range mt-1.5 w-full h-1 bg-white/10 rounded-full appearance-none outline-none">
                                    <span id="timelineCropYValue" class="text-white/70">0%</span>
                                </label>
                            </div>
                        </div>

                        <div class="mt-3 rounded-xl border border-white/10 bg-black/35 p-3">
                            <p class="text-xs text-white/70 mb-2">Add / Paste</p>
                            <input id="timelineOverlayTextInput" type="text" placeholder="Texto para sobreposição..." class="w-full bg-black/50 border border-white/10 rounded-lg px-3 py-2 text-xs text-white outline-none focus:border-accent/50">
                            <div class="mt-2 grid grid-cols-2 gap-2">
                                <button id="timelineAddOverlayBtn" class="px-3 py-2 text-xs rounded-lg bg-accent/15 border border-accent/30 text-accent hover:bg-accent hover:text-bg transition-colors">Add Text</button>
                                <button id="timelineCopyStyleBtn" class="px-3 py-2 text-xs rounded-lg border border-white/25 text-white/80 hover:border-white/40 hover:text-white transition-colors">Copy Style</button>
                            </div>
                            <div class="mt-2 grid grid-cols-2 gap-2">
                                <button id="timelinePasteStyleBtn" class="px-3 py-2 text-xs rounded-lg border border-white/25 text-white/80 hover:border-white/40 hover:text-white transition-colors">Paste Style</button>
                                <button class="px-3 py-2 text-xs rounded-lg border border-accent/25 text-accent/90 bg-accent/10">AI Process Ready</button>
                            </div>
                        </div>

                        <div class="mt-3 rounded-xl border border-white/10 bg-black/35 p-3">
                            <p class="text-xs text-white/70 mb-2">Overlay items</p>
                            <div id="timelineOverlayList" class="max-h-[200px] overflow-auto custom-scrollbar space-y-2 text-xs"></div>
                        </div>
                    </aside>
                </div>
            </div>
        </div>
    </div>

    <!-- WebGL Background -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const VERT = `
            attribute float aIndex;
            attribute float aSize;
            uniform float uTime;
            varying float vAlpha;
            varying vec3 vColor;
            float hash(float n) { return fract(sin(n + 0.1) * 43758.5453); }
            void main() {
                float t = uTime * 0.1;
                float x = (hash(aIndex) - 0.5) * 20.0;
                float y = (hash(aIndex * 2.0) - 0.5) * 20.0 + sin(t + aIndex) * 2.0;
                float z = (hash(aIndex * 3.0) - 0.5) * 10.0;
                vec3 pos = vec3(x, y, z);
                vColor = mix(vec3(0.78, 1.0, 0.0), vec3(1.0), hash(aIndex * 5.0));
                vAlpha = (0.1 + hash(aIndex) * 0.3) * (sin(uTime * 2.0 + aIndex) * 0.5 + 0.5);
                vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = aSize * (50.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }
        `;
        const FRAG = `
            varying float vAlpha;
            varying vec3 vColor;
            void main() {
                float d = length(gl_PointCoord - 0.5);
                if (d > 0.5) discard;
                float a = (1.0 - smoothstep(0.1, 0.5, d)) * vAlpha;
                gl_FragColor = vec4(vColor, a);
            }
        `;

        class SimpleVoid {
            constructor(canvas) {
                this.N = 2000;
                this.ren = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: true });
                this.ren.setSize(innerWidth, innerHeight);
                this.ren.setPixelRatio(Math.min(devicePixelRatio, 2));
                this.cam = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
                this.cam.position.z = 8;
                this.scene = new THREE.Scene();
                const geo = new THREE.BufferGeometry();
                const idx = new Float32Array(this.N), sizes = new Float32Array(this.N);
                for(let i=0; i<this.N; i++) { idx[i] = i; sizes[i] = 1.0 + Math.random() * 2.0; }
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.N * 3), 3));
                geo.setAttribute('aIndex', new THREE.BufferAttribute(idx, 1));
                geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
                this.mat = new THREE.ShaderMaterial({ vertexShader: VERT, fragmentShader: FRAG, uniforms: { uTime: { value: 0 } }, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
                this.points = new THREE.Points(geo, this.mat);
                this.scene.add(this.points);
                window.addEventListener('resize', () => this.resize());
                this.loop();
            }
            resize() { this.cam.aspect = innerWidth / innerHeight; this.cam.updateProjectionMatrix(); this.ren.setSize(innerWidth, innerHeight); }
            loop() { requestAnimationFrame(() => this.loop()); this.mat.uniforms.uTime.value = performance.now() * 0.001; this.points.rotation.y = performance.now() * 0.00005; this.ren.render(this.scene, this.cam); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SimpleVoid(document.getElementById('voidCanvas'));

            const landingPage = document.getElementById('landing-page');
            const appInterface = document.getElementById('app-interface');
            const earlyAccessForm = document.getElementById('earlyAccessForm');
            const earlyAccessBtn = document.getElementById('earlyAccessBtn');
            const inputSection = document.getElementById('inputSection');
            const generateForm = document.getElementById('generateForm');
            const generateBtn = document.getElementById('generateBtn');
            const resultsSection = document.getElementById('resultsSection');
            const editorSection = document.getElementById('editorSection');
            const fileInput = document.getElementById('fileInput');
            const dropText = document.getElementById('dropText');
            const generateStatus = document.getElementById('generateStatus');
            const workflowStageBadge = document.getElementById('workflowStageBadge');
            const workflowNextAction = document.getElementById('workflowNextAction');
            const wfSourceCard = document.getElementById('wfSourceCard');
            const wfSourceState = document.getElementById('wfSourceState');
            const wfClipsCard = document.getElementById('wfClipsCard');
            const wfClipsState = document.getElementById('wfClipsState');
            const wfEditorCard = document.getElementById('wfEditorCard');
            const wfEditorState = document.getElementById('wfEditorState');
            const wfCaptionCard = document.getElementById('wfCaptionCard');
            const wfCaptionState = document.getElementById('wfCaptionState');
            const wfDeliveryCard = document.getElementById('wfDeliveryCard');
            const wfDeliveryState = document.getElementById('wfDeliveryState');
            const guideFocusSourceBtn = document.getElementById('guideFocusSourceBtn');
            const guideOpenEditorBtn = document.getElementById('guideOpenEditorBtn');
            const guideTranscribeBtn = document.getElementById('guideTranscribeBtn');
            const guideExportBtn = document.getElementById('guideExportBtn');
            const guidePackBtn = document.getElementById('guidePackBtn');
            const guideDiagnoseBtn = document.getElementById('guideDiagnoseBtn');
            const backendStatus = document.getElementById('backendStatus');
            const sourceSummary = document.getElementById('sourceSummary');
            const videoUrlInput = document.getElementById('videoUrlInput');
            const clipGrid = document.getElementById('clipGrid');
            const processingCard = document.getElementById('processingCard');
            const captionList = document.getElementById('captionList');
            const transcribeCaptionsBtn = document.getElementById('transcribeCaptionsBtn');
            const transcribeStatus = document.getElementById('transcribeStatus');
            const youtubeCookiesInput = document.getElementById('youtubeCookiesInput');
            const saveYoutubeCookiesBtn = document.getElementById('saveYoutubeCookiesBtn');
            const clearYoutubeCookiesBtn = document.getElementById('clearYoutubeCookiesBtn');
            const youtubeCookiesStatus = document.getElementById('youtubeCookiesStatus');
            const filterBtns = Array.from(document.querySelectorAll('.filter-btn'));
            const themeFilterSelect = document.getElementById('themeFilterSelect');
            const subjectFilterSelect = document.getElementById('subjectFilterSelect');
            const editorTitle = document.getElementById('editorTitle');
            const editorVideo = document.getElementById('editorVideo');
            const editorYoutubeWrap = document.getElementById('editorYoutubeWrap');
            const editorYoutubeBlockedWrap = document.getElementById('editorYoutubeBlockedWrap');
            const editorYoutubeBlockedText = document.getElementById('editorYoutubeBlockedText');
            const captionPreviewOverlay = document.getElementById('captionPreviewOverlay');
            const captionPreviewText = document.getElementById('captionPreviewText');
            const clipOverlayLayer = document.getElementById('clipOverlayLayer');
            const editorStatus = document.getElementById('editorStatus');
            const clipStartInput = document.getElementById('clipStartInput');
            const clipEndInput = document.getElementById('clipEndInput');
            const clipDurationLabel = document.getElementById('clipDurationLabel');
            const playBtn = document.getElementById('mainPlayBtn');
            const playIcon = document.getElementById('mainPlayIcon');
            const progressTrack = document.getElementById('videoProgress');
            const progressBar = document.getElementById('videoProgressBar');
            const timeLabel = document.getElementById('videoTime');
            const openTimelineBtn = document.getElementById('openTimelineBtn');
            const renderBtn = document.getElementById('renderBtn');
            const captionFontFamilySelect = document.getElementById('captionFontFamilySelect');
            const captionWeightSelect = document.getElementById('captionWeightSelect');
            const captionTextColorInput = document.getElementById('captionTextColorInput');
            const captionBgColorInput = document.getElementById('captionBgColorInput');
            const captionFontSizeInput = document.getElementById('captionFontSizeInput');
            const captionSizeValue = document.getElementById('captionSizeValue');
            const captionBgOpacityInput = document.getElementById('captionBgOpacityInput');
            const captionBgOpacityValue = document.getElementById('captionBgOpacityValue');
            const captionPositionSelect = document.getElementById('captionPositionSelect');
            const captionCaseSelect = document.getElementById('captionCaseSelect');
            const captionStrokeColorInput = document.getElementById('captionStrokeColorInput');
            const captionStrokeSizeInput = document.getElementById('captionStrokeSizeInput');
            const musicVolumeInput = document.getElementById('musicVolumeInput');
            const voiceVolumeInput = document.getElementById('voiceVolumeInput');
            const musicVolumeLabel = document.getElementById('musicVolumeLabel');
            const voiceVolumeLabel = document.getElementById('voiceVolumeLabel');
            const spaceNameInput = document.getElementById('spaceNameInput');
            const connectSpaceBtn = document.getElementById('connectSpaceBtn');
            const spaceStatus = document.getElementById('spaceStatus');
            const generateThumbBtn = document.getElementById('generateThumbBtn');
            const generateTitlesBtn = document.getElementById('generateTitlesBtn');
            const generateHashtagsBtn = document.getElementById('generateHashtagsBtn');
            const downloadPackBtn = document.getElementById('downloadPackBtn');
            const spaceOutputs = document.getElementById('spaceOutputs');
            const commandChatLog = document.getElementById('commandChatLog');
            const commandInput = document.getElementById('commandInput');
            const commandMicBtn = document.getElementById('commandMicBtn');
            const commandSendBtn = document.getElementById('commandSendBtn');
            const commandShortcutBar = document.getElementById('commandShortcutBar');
            const voiceStatus = document.getElementById('voiceStatus');
            const agentIdBadge = document.getElementById('agentIdBadge');
            const agentStatus = document.getElementById('agentStatus');
            const agentConnectBtn = document.getElementById('agentConnectBtn');
            const captionStyleSection = document.getElementById('captionStyleSection');
            const audioMixSection = document.getElementById('audioMixSection');
            const spaceHubSection = document.getElementById('spaceHubSection');
            const commandChatSection = document.getElementById('commandChatSection');
            const editorTabCaptions = document.getElementById('editorTabCaptions');
            const editorTabAudio = document.getElementById('editorTabAudio');
            const editorTabStyles = document.getElementById('editorTabStyles');
            const editorTabComplement = document.getElementById('editorTabComplement');
            const editorTabBtns = Array.from(document.querySelectorAll('.editor-tab-btn'));
            const editorMainPanels = Array.from(document.querySelectorAll('.editor-main-panel'));
            const complementPanel = document.getElementById('complementPanel');
            const complementProviderSelect = document.getElementById('complementProviderSelect');
            const complementApiKeyInput = document.getElementById('complementApiKeyInput');
            const complementSaveKeyBtn = document.getElementById('complementSaveKeyBtn');
            const complementClearKeyBtn = document.getElementById('complementClearKeyBtn');
            const complementStatus = document.getElementById('complementStatus');
            const complementChatLog = document.getElementById('complementChatLog');
            const complementChatInput = document.getElementById('complementChatInput');
            const complementChatSendBtn = document.getElementById('complementChatSendBtn');
            const complementAutoFillBtn = document.getElementById('complementAutoFillBtn');
            const complementRegenerateBtn = document.getElementById('complementRegenerateBtn');
            const complementImageList = document.getElementById('complementImageList');

            const videoAutomationModal = document.getElementById('videoAutomationModal');
            const videoAutomationCloseBtn = document.getElementById('videoAutomationCloseBtn');
            const automationSpaceTitle = document.getElementById('automationSpaceTitle');
            const automationSpaceFooterName = document.getElementById('automationSpaceFooterName');
            const automationPromptInput = document.getElementById('automationPromptInput');
            const automationApplyPromptBtn = document.getElementById('automationApplyPromptBtn');
            const automationPromptStatus = document.getElementById('automationPromptStatus');
            const automationNodeTypeBadge = document.getElementById('automationNodeTypeBadge');
            const automationSelectedNodeLabel = document.getElementById('automationSelectedNodeLabel');
            const automationNodeNameInput = document.getElementById('automationNodeNameInput');
            const automationNodeDelayInput = document.getElementById('automationNodeDelayInput');
            const automationNodePresetSelect = document.getElementById('automationNodePresetSelect');
            const automationNodeAutoThumb = document.getElementById('automationNodeAutoThumb');
            const automationNodeAutoHashtags = document.getElementById('automationNodeAutoHashtags');
            const automationNodeSaveBtn = document.getElementById('automationNodeSaveBtn');
            const automationNodesCount = document.getElementById('automationNodesCount');
            const automationSuccessRate = document.getElementById('automationSuccessRate');
            const automationRunBtn = document.getElementById('automationRunBtn');
            const automationDeployBtn = document.getElementById('automationDeployBtn');
            const automationIngestBtn = document.getElementById('automationIngestBtn');
            const automationLoadTemplatesBtn = document.getElementById('automationLoadTemplatesBtn');
            const automationPatchTimestampInput = document.getElementById('automationPatchTimestampInput');
            const automationPatchInstructionInput = document.getElementById('automationPatchInstructionInput');
            const automationPatchProviderSelect = document.getElementById('automationPatchProviderSelect');
            const automationCreatePatchBtn = document.getElementById('automationCreatePatchBtn');
            const automationExecutePatchBtn = document.getElementById('automationExecutePatchBtn');
            const automationPlanRenderBtn = document.getElementById('automationPlanRenderBtn');
            const automationExecuteRenderBtn = document.getElementById('automationExecuteRenderBtn');
            const automationInfraStatus = document.getElementById('automationInfraStatus');
            const automationInfraLog = document.getElementById('automationInfraLog');
            const automarNodeButtons = Array.from(document.querySelectorAll('.automar-node'));

            const timelineModal = document.getElementById('timelineModal');
            const timelineCloseBtn = document.getElementById('timelineCloseBtn');
            const timelineClipTitle = document.getElementById('timelineClipTitle');
            const timelineStatus = document.getElementById('timelineStatus');
            const timelineScrubber = document.getElementById('timelineScrubber');
            const timelineStartValue = document.getElementById('timelineStartValue');
            const timelinePlayheadValue = document.getElementById('timelinePlayheadValue');
            const timelineEndValue = document.getElementById('timelineEndValue');
            const timelineDurationValue = document.getElementById('timelineDurationValue');
            const timelinePlayheadNeedle = document.getElementById('timelinePlayheadNeedle');
            const timelinePlayheadTag = document.getElementById('timelinePlayheadTag');
            const timelinePlayBtn = document.getElementById('timelinePlayBtn');
            const timelineSetInBtn = document.getElementById('timelineSetInBtn');
            const timelineSetOutBtn = document.getElementById('timelineSetOutBtn');
            const timelineCutLeftBtn = document.getElementById('timelineCutLeftBtn');
            const timelineCutRightBtn = document.getElementById('timelineCutRightBtn');
            const timelineResetBtn = document.getElementById('timelineResetBtn');
            const timelineCropZoom = document.getElementById('timelineCropZoom');
            const timelineCropX = document.getElementById('timelineCropX');
            const timelineCropY = document.getElementById('timelineCropY');
            const timelineCropZoomValue = document.getElementById('timelineCropZoomValue');
            const timelineCropXValue = document.getElementById('timelineCropXValue');
            const timelineCropYValue = document.getElementById('timelineCropYValue');
            const timelineOverlayTextInput = document.getElementById('timelineOverlayTextInput');
            const timelineAddOverlayBtn = document.getElementById('timelineAddOverlayBtn');
            const timelineOverlayList = document.getElementById('timelineOverlayList');
            const timelineCopyStyleBtn = document.getElementById('timelineCopyStyleBtn');
            const timelinePasteStyleBtn = document.getElementById('timelinePasteStyleBtn');
            const timelineOpenEditorBtn = document.getElementById('timelineOpenEditorBtn');

            const DEFAULT_ELEVEN_AGENT_ID = 'agent_3701khd9583qe1ctjzvqxtz38cfa';
            const COMPLEMENT_PROVIDER_STORAGE_KEY = 'jv_complement_provider';
            const COMPLEMENT_OPENAI_KEY_STORAGE_KEY = 'jv_complement_openai_key';
            const YOUTUBE_COOKIES_STORAGE_KEY = 'jv_youtube_cookies';

            const clipThemes = [
                { title: 'Open With the Bold Claim', hook: 'Hook: Bold Claim' },
                { title: 'The Surprising Shift', hook: 'Hook: Surprise' },
                { title: 'Problem and Turning Point', hook: 'Hook: Problem' },
                { title: 'Lesson With Example', hook: 'Hook: Insight' },
                { title: 'Final Takeaway Push', hook: 'Hook: CTA' },
                { title: 'Quick Story Arc', hook: 'Hook: Story' },
                { title: 'Counterpoint Breakdown', hook: 'Hook: Debate' },
                { title: 'Myth Vs Reality', hook: 'Hook: Myth Bust' },
                { title: 'Fast Tactical Tutorial', hook: 'Hook: Tutorial' },
                { title: 'Data Point Shock', hook: 'Hook: Stats' }
            ];

            const appState = {
                sourceSrc: '',
                sourceLabel: '',
                sourceKind: '',
                youtubeVideoId: '',
                youtubeLastErrorCode: null,
                youtubePlaybackBlocked: false,
                youtubePlaybackBlockReason: '',
                youtubeCookies: '',
                ingestedMediaBlob: null,
                captionsSource: 'template',
                exportCount: 0,
                packCount: 0,
                objectUrl: null,
                duration: 0,
                clips: [],
                activeClipId: null,
                activeCaptionId: null,
                activeFilter: 'all',
                activeThemeFilter: 'all',
                activeSubjectFilter: 'all',
                transcriptWords: [],
                transcribeInFlight: false,
                elevenAgentId: DEFAULT_ELEVEN_AGENT_ID,
                style: {
                    fontFamily: 'body',
                    fontWeight: '700',
                    textColor: '#ffffff',
                    bgColor: '#000000',
                    bgOpacity: 52,
                    fontSize: 38,
                    position: 'bottom',
                    textCase: 'normal',
                    strokeColor: '#000000',
                    strokeSize: 2
                },
                audio: {
                    music: 15,
                    voice: 100
                },
                space: {
                    connected: false,
                    name: '',
                    thumbs: [],
                    titles: [],
                    hashtags: []
                },
                automation: {
                    selectedNodeId: 'trigger_new_video',
                    successRate: 99.1,
                    nodes: {},
                    templates: [],
                    ingest: null,
                    patchLayers: [],
                    renderPlan: null,
                    lastPatchResult: null,
                    lastRenderResult: null
                },
                timeline: {
                    open: false,
                    clipId: null
                },
                clipboard: {
                    clipStyle: null,
                    crop: null
                },
                complement: {
                    provider: 'openai',
                    apiKey: '',
                    tab: 'captions',
                    busy: false
                },
                backend: {
                    checked: false,
                    online: false,
                    hasElevenLabsKey: false,
                    hasOpenAiKey: false,
                    hasYoutubeCookies: false,
                    directTranscribeReady: false,
                    youtubeTranscribeReady: false,
                    imageGenerationReady: false,
                    videoEditReady: false,
                    ytDlpAvailable: false,
                    ytDlpBin: '',
                    ffmpegAvailable: false,
                    ffmpegBin: '',
                    runtime: '',
                    healthUrl: '',
                    keyVaultReady: false,
                    error: ''
                }
            };

            const metadataProbe = document.createElement('video');
            metadataProbe.preload = 'metadata';
            metadataProbe.crossOrigin = 'anonymous';
            metadataProbe.playsInline = true;

            let youtubeApiPromise = null;
            let youtubePlayerInitPromise = null;
            let youtubePlayer = null;
            let youtubeCurrentVideoId = '';
            let youtubeProgressTicker = null;
            let speechRecognition = null;
            let voiceListening = false;
            let elevenAgentSocket = null;
            let elevenAgentConnectPromise = null;
            let elevenAgentPendingResolver = null;
            let backendHealthPromise = null;
            let backendHealthLastCheckAt = 0;
            let timelineSyncTicker = null;

            editorTitle.setAttribute('contenteditable', 'true');
            editorTitle.spellcheck = false;

            function setGenerateStatus(message, tone = 'muted') {
                generateStatus.textContent = message || '';
                generateStatus.classList.remove('text-red-300', 'text-accent', 'text-white/50');
                if (tone === 'error') generateStatus.classList.add('text-red-300');
                else if (tone === 'success') generateStatus.classList.add('text-accent');
                else generateStatus.classList.add('text-white/50');
            }

            function setEditorStatus(message, tone = 'muted') {
                editorStatus.textContent = message || '';
                editorStatus.classList.remove('text-red-300', 'text-accent', 'text-white/50');
                if (tone === 'error') editorStatus.classList.add('text-red-300');
                else if (tone === 'success') editorStatus.classList.add('text-accent');
                else editorStatus.classList.add('text-white/50');
            }

            function setTranscribeStatus(message, tone = 'muted') {
                transcribeStatus.textContent = message || '';
                transcribeStatus.classList.remove('text-red-300', 'text-accent', 'text-white/50');
                if (tone === 'error') transcribeStatus.classList.add('text-red-300');
                else if (tone === 'success') transcribeStatus.classList.add('text-accent');
                else transcribeStatus.classList.add('text-white/50');
            }

            function setYoutubeCookiesStatus(message, tone = 'muted') {
                if (!youtubeCookiesStatus) return;
                youtubeCookiesStatus.textContent = message || '';
                youtubeCookiesStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') youtubeCookiesStatus.classList.add('text-red-300');
                else if (tone === 'success') youtubeCookiesStatus.classList.add('text-accent');
                else youtubeCookiesStatus.classList.add('text-white/40');
            }

            function setAgentStatus(message, tone = 'muted') {
                agentStatus.textContent = message || '';
                agentStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') agentStatus.classList.add('text-red-300');
                else if (tone === 'success') agentStatus.classList.add('text-accent');
                else agentStatus.classList.add('text-white/40');
            }

            function setBackendStatus(message, tone = 'muted') {
                backendStatus.textContent = message || '';
                backendStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') backendStatus.classList.add('text-red-300');
                else if (tone === 'success') backendStatus.classList.add('text-accent');
                else backendStatus.classList.add('text-white/40');
            }

            function setComplementStatus(message, tone = 'muted') {
                complementStatus.textContent = message || '';
                complementStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') complementStatus.classList.add('text-red-300');
                else if (tone === 'success') complementStatus.classList.add('text-accent');
                else complementStatus.classList.add('text-white/40');
            }

            function addComplementMessage(role, text) {
                const bubble = document.createElement('div');
                bubble.className = role === 'user'
                    ? 'bg-white/5 border border-white/10 rounded px-2 py-1 text-white/90'
                    : 'bg-accent/10 border border-accent/20 rounded px-2 py-1 text-white/90';
                bubble.innerHTML = `<span class="text-[10px] uppercase tracking-wide ${role === 'user' ? 'text-white/40' : 'text-accent'}">${role === 'user' ? 'Você' : 'Fill AI'}</span><div class="mt-1">${escapeHtml(text)}</div>`;
                complementChatLog.appendChild(bubble);
                complementChatLog.scrollTop = complementChatLog.scrollHeight;
            }

            function getSavedComplementKeyStorageKey(provider) {
                if (provider === 'openai') return COMPLEMENT_OPENAI_KEY_STORAGE_KEY;
                return COMPLEMENT_OPENAI_KEY_STORAGE_KEY;
            }

            function getSavedComplementApiKey(provider) {
                try {
                    const key = localStorage.getItem(getSavedComplementKeyStorageKey(provider));
                    return key ? String(key) : '';
                } catch (_error) {
                    return '';
                }
            }

            function saveComplementApiKey(provider, key) {
                try {
                    localStorage.setItem(getSavedComplementKeyStorageKey(provider), key);
                } catch (_error) {
                    // noop
                }
            }

            function clearComplementApiKey(provider) {
                try {
                    localStorage.removeItem(getSavedComplementKeyStorageKey(provider));
                } catch (_error) {
                    // noop
                }
            }

            function saveComplementProvider(provider) {
                try {
                    localStorage.setItem(COMPLEMENT_PROVIDER_STORAGE_KEY, provider);
                } catch (_error) {
                    // noop
                }
            }

            function loadComplementSettings() {
                let provider = 'openai';
                try {
                    const savedProvider = localStorage.getItem(COMPLEMENT_PROVIDER_STORAGE_KEY);
                    if (savedProvider) provider = String(savedProvider).trim().toLowerCase() || 'openai';
                } catch (_error) {
                    provider = 'openai';
                }
                appState.complement.provider = provider === 'openai' ? 'openai' : 'openai';
                appState.complement.apiKey = getSavedComplementApiKey(appState.complement.provider);
                complementProviderSelect.value = appState.complement.provider;
                complementApiKeyInput.value = appState.complement.apiKey;
            }

            function getSavedYoutubeCookies() {
                try {
                    const raw = localStorage.getItem(YOUTUBE_COOKIES_STORAGE_KEY);
                    return raw ? String(raw) : '';
                } catch (_error) {
                    return '';
                }
            }

            function saveYoutubeCookies(rawCookies) {
                try {
                    localStorage.setItem(YOUTUBE_COOKIES_STORAGE_KEY, String(rawCookies || ''));
                } catch (_error) {
                    // noop
                }
            }

            function clearSavedYoutubeCookies() {
                try {
                    localStorage.removeItem(YOUTUBE_COOKIES_STORAGE_KEY);
                } catch (_error) {
                    // noop
                }
            }

            function loadYoutubeCookieSettings() {
                const saved = getSavedYoutubeCookies();
                appState.youtubeCookies = saved;
                if (youtubeCookiesInput) {
                    youtubeCookiesInput.value = saved;
                }
                if (saved.trim()) {
                    setYoutubeCookiesStatus('Cookies salvos localmente e prontos para transcrição.', 'success');
                } else {
                    setYoutubeCookiesStatus('Salvo apenas neste navegador (opcional).', 'muted');
                }
            }

            function getResolvedYoutubeCookies() {
                if (youtubeCookiesInput) {
                    const typed = String(youtubeCookiesInput.value || '').trim();
                    if (typed) return typed;
                }
                return String(appState.youtubeCookies || '').trim();
            }

            function getClipTranscriptContext(clip, maxWords = 42) {
                if (!clip || !Array.isArray(clip.captions) || !clip.captions.length) return '';
                const joined = clip.captions
                    .map((caption) => String(caption.text || '').trim())
                    .filter(Boolean)
                    .join(' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                if (!joined) return '';
                const words = joined.split(' ');
                return words.slice(0, maxWords).join(' ');
            }

            function buildAttentionImagePrompt(context, userIntent = '') {
                const safeContext = String(context || '').trim();
                const safeIntent = String(userIntent || '').trim();
                const focus = safeIntent || 'create an attention-grabbing contextual b-roll scene';
                const base = `${focus}. vertical frame for short-form video, cinematic lighting, realistic details, clean composition, no text, no watermark`;
                if (!safeContext) return `${base}.`;
                return `${base}. Scene context from narration: "${safeContext}".`;
            }

            function collectSpeechGapsForClip(clip, minGapSeconds = 1.5) {
                if (!clip) return [];
                const captions = Array.isArray(clip.captions)
                    ? clip.captions.slice().sort((a, b) => Number(a.time) - Number(b.time))
                    : [];
                const gaps = [];
                let cursor = clip.start;

                captions.forEach((caption, index) => {
                    const capStart = clamp(Number(caption.time) || clip.start, clip.start, clip.end);
                    const gapStart = cursor;
                    const gapEnd = Math.max(gapStart, capStart - 0.08);
                    if (gapEnd - gapStart >= minGapSeconds) {
                        const prevText = index > 0 ? String(captions[index - 1].text || '').trim() : '';
                        const nextText = String(caption.text || '').trim();
                        gaps.push({
                            start: roundTenth(gapStart),
                            end: roundTenth(gapEnd),
                            context: `${prevText} ${nextText}`.trim()
                        });
                    }
                    cursor = Math.max(cursor, capStart + 1.25);
                });

                if (clip.end - cursor >= minGapSeconds) {
                    const tailContext = captions.length ? String(captions[captions.length - 1].text || '').trim() : '';
                    gaps.push({
                        start: roundTenth(cursor),
                        end: roundTenth(clip.end),
                        context: tailContext
                    });
                }

                return gaps.slice(0, 5);
            }

            function renderComplementImageList() {
                const clip = getActiveClip();
                if (!clip || !complementImageList) {
                    complementImageList.innerHTML = '<div class="text-white/40 text-xs">Selecione um clip para gerar preenchimentos.</div>';
                    return;
                }
                ensureClipEditData(clip);
                if (!Array.isArray(clip.fillerShots) || !clip.fillerShots.length) {
                    complementImageList.innerHTML = '<div class="text-white/40 text-xs">Nenhuma imagem complementar no clip ativo.</div>';
                    return;
                }

                complementImageList.innerHTML = clip.fillerShots.map((shot) => `
                    <div class="rounded-lg border border-white/10 bg-black/40 p-2">
                        <div class="flex gap-2">
                            <div class="w-14 h-14 rounded overflow-hidden border border-white/10 bg-black/40 shrink-0">
                                <img src="${escapeHtml(shot.src)}" alt="filler" class="w-full h-full object-cover">
                            </div>
                            <div class="min-w-0 flex-1">
                                <p class="text-white/80 text-[11px] leading-snug line-clamp-2">${escapeHtml(shot.prompt || 'Filler visual')}</p>
                                <p class="text-[10px] text-white/40 mt-1 font-mono">${formatTime(shot.start)} - ${formatTime(shot.end)}</p>
                            </div>
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button class="text-[11px] px-2 py-1 rounded border border-white/20 text-white/70 hover:border-white/40 hover:text-white transition-colors" data-complement-jump="${escapeHtml(shot.id)}">ir</button>
                            <button class="text-[11px] px-2 py-1 rounded border border-red-400/30 text-red-300 hover:bg-red-400/10 transition-colors" data-complement-remove="${escapeHtml(shot.id)}">remover</button>
                        </div>
                    </div>
                `).join('');
            }

            function normalizeLocalHost(host) {
                const clean = String(host || '').replace(/^\[|\]$/g, '');
                if (!clean) return '127.0.0.1';
                if (clean === 'localhost' || clean === '::1' || clean === '0.0.0.0') return '127.0.0.1';
                return clean;
            }

            function isLocalDevelopmentHost(host) {
                const clean = String(host || '').replace(/^\[|\]$/g, '').toLowerCase();
                return clean === 'localhost' || clean === '127.0.0.1' || clean === '::1' || clean === '0.0.0.0';
            }

            function resolveBackendHost() {
                return normalizeLocalHost(window.location.hostname);
            }

            function resolveBackendApiBase() {
                if (window.location.protocol === 'file:') return 'http://127.0.0.1:8787';
                if (window.location.port === '8787') return window.location.origin;
                if (!/^https?:$/.test(window.location.protocol)) return 'http://127.0.0.1:8787';
                if (isLocalDevelopmentHost(window.location.hostname)) {
                    const host = resolveBackendHost();
                    return `${window.location.protocol}//${host}:8787`;
                }
                return window.location.origin;
            }

            function isHostedDeploymentContext() {
                if (window.location.protocol === 'file:') return false;
                if (!/^https?:$/.test(window.location.protocol)) return false;
                if (window.location.port === '8787') return false;
                return !isLocalDevelopmentHost(window.location.hostname);
            }

            function resolveHealthApiUrls() {
                const base = resolveBackendApiBase();
                const urls = [
                    `${base}/api/health`,
                    `${base}/health`
                ];
                if (!isHostedDeploymentContext()) {
                    urls.push(
                        'http://127.0.0.1:8787/api/health',
                        'http://127.0.0.1:8787/health',
                        'http://localhost:8787/api/health',
                        'http://localhost:8787/health'
                    );
                }
                return [...new Set(urls)];
            }

            function resolveHealthApiUrl() {
                return resolveHealthApiUrls()[0];
            }

            function resolveAgentSignedUrlApi() {
                return `${resolveBackendApiBase()}/api/agent/signed-url?agentId=${encodeURIComponent(appState.elevenAgentId || '')}`;
            }

            function resolveYoutubeMetadataApiUrl() {
                return `${resolveBackendApiBase()}/api/youtube/metadata`;
            }

            function resolveYoutubeIngestApiUrl() {
                return `${resolveBackendApiBase()}/api/youtube/ingest`;
            }

            function resolveTranscribeApiUrl() {
                return `${resolveBackendApiBase()}/api/transcribe`;
            }

            function resolveComplementImageApiUrl() {
                return `${resolveBackendApiBase()}/api/complement/image`;
            }

            function resolveAutomationIngestApiUrl() {
                return `${resolveBackendApiBase()}/api/automation`;
            }

            function resolveAutomationFramePatchApiUrl() {
                return `${resolveBackendApiBase()}/api/automation`;
            }

            function resolveAutomationMotionApiUrl() {
                return `${resolveBackendApiBase()}/api/automation`;
            }

            function resolveAutomationRenderApiUrl() {
                return `${resolveBackendApiBase()}/api/automation`;
            }

            function resolveWorkflowTemplatesApiUrl() {
                return `${resolveBackendApiBase()}/api/workflow`;
            }

            function resolveWorkflowApplyApiUrl() {
                return `${resolveBackendApiBase()}/api/workflow`;
            }

            function resolveKeyVaultSaveApiUrl() {
                return `${resolveBackendApiBase()}/api/keys`;
            }

            async function fetchWithTimeout(url, options = {}, timeoutMs = 20000) {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), timeoutMs);
                try {
                    return await fetch(url, { ...options, signal: controller.signal });
                } finally {
                    clearTimeout(timeout);
                }
            }

            async function fetchBackendJson(url, options = {}, timeoutMs = 30000) {
                const response = await fetchWithTimeout(url, options, timeoutMs);
                const raw = await response.text();
                let payload = {};
                try {
                    payload = raw ? JSON.parse(raw) : {};
                } catch (_error) {
                    payload = { error: raw || 'Resposta inválida do backend.' };
                }
                if (!response.ok) {
                    const error = new Error(payload.error || `Erro HTTP ${response.status}.`);
                    error.statusCode = response.status;
                    error.payload = payload;
                    throw error;
                }
                return payload;
            }

            function updateAgentBadge() {
                agentIdBadge.textContent = `Agent: ${appState.elevenAgentId || 'not set'}`;
            }

            function buildBackendDiagnosticMessage() {
                if (!appState.backend.checked) {
                    return 'Diagnóstico: backend ainda não checado.';
                }
                const lines = [];
                lines.push(appState.backend.online ? 'Backend: online' : 'Backend: offline');
                if (appState.backend.runtime) lines.push(`Runtime: ${appState.backend.runtime}`);
                lines.push(appState.backend.hasElevenLabsKey ? 'ElevenLabs key: OK' : 'ElevenLabs key: ausente');
                lines.push(appState.backend.hasYoutubeCookies ? 'YouTube cookies (backend): OK' : 'YouTube cookies (backend): ausente');
                lines.push(getResolvedYoutubeCookies() ? 'YouTube cookies (browser): OK' : 'YouTube cookies (browser): ausente');
                lines.push(appState.backend.keyVaultReady ? 'Key Vault: pronto' : 'Key Vault: pendente');
                lines.push(appState.backend.imageGenerationReady ? 'Complement image API: pronta' : 'Complement image API: usando key local da aba');
                lines.push(appState.backend.videoEditReady ? `Video runtime: OK (${appState.backend.ffmpegBin || 'ffmpeg'})` : 'Video runtime: ffmpeg indisponível');
                lines.push(appState.backend.ytDlpAvailable ? `yt-dlp: OK (${appState.backend.ytDlpBin || 'yt-dlp'})` : `yt-dlp: indisponível (${appState.backend.ytDlpBin || 'yt-dlp'})`);
                if (appState.backend.healthUrl) lines.push(`Health: ${appState.backend.healthUrl}`);
                if (appState.sourceKind === 'youtube') {
                    lines.push(appState.backend.youtubeTranscribeReady ? 'YouTube + transcrição: pronto' : 'YouTube + transcrição: pendente');
                } else {
                    lines.push(appState.backend.directTranscribeReady ? 'Transcrição de arquivo/link: pronta' : 'Transcrição de arquivo/link: pendente');
                }
                if (appState.backend.error) lines.push(`Erro: ${appState.backend.error}`);
                return lines.join(' | ');
            }

            function getBackendOfflineInstruction(detail = '') {
                const tail = detail ? ` (${detail})` : '';
                if (isHostedDeploymentContext()) {
                    return `Backend do deploy indisponível${tail}. Verifique Functions e Deployment Protection na Vercel.`;
                }
                return 'Backend offline. Inicie com: node server.mjs (porta 8787).';
            }

            function getTranscribeBlockingReason() {
                if (!appState.backend.online) {
                    return isHostedDeploymentContext()
                        ? 'Backend de transcrição do deploy está indisponível. Verifique logs e env vars na Vercel.'
                        : 'Servidor local indisponível na porta 8787. Rode: `node server.mjs`.';
                }
                if (!appState.backend.hasElevenLabsKey) {
                    return isHostedDeploymentContext()
                        ? 'ELEVENLABS_API_KEY ausente na Vercel (Environment Variables).'
                        : 'ELEVENLABS_API_KEY ausente no backend (.env).';
                }
                if (appState.sourceKind === 'youtube' && !appState.backend.ytDlpAvailable) {
                    // Serverless deploy can use HTTP fallback without yt-dlp binary.
                    if (!isHostedDeploymentContext() && appState.backend.runtime !== 'serverless') {
                        return `yt-dlp indisponível (${appState.backend.ytDlpBin || 'yt-dlp'}). Instale para transcrever YouTube automaticamente.`;
                    }
                }
                return '';
            }

            function paintWorkflowCard(card, stateNode, state, message) {
                if (!card || !stateNode) return;
                stateNode.textContent = message;
                card.classList.remove('border-white/10', 'border-accent/40', 'bg-accent/[0.06]', 'bg-white/[0.01]');
                stateNode.classList.remove('text-white/40', 'text-accent');

                if (state === 'done') {
                    card.classList.add('border-accent/40', 'bg-accent/[0.06]');
                    stateNode.classList.add('text-accent');
                } else if (state === 'active') {
                    card.classList.add('border-accent/40', 'bg-white/[0.01]');
                    stateNode.classList.add('text-accent');
                } else {
                    card.classList.add('border-white/10', 'bg-white/[0.01]');
                    stateNode.classList.add('text-white/40');
                }
            }

            function computeCurrentStage() {
                if (!appState.sourceSrc) return 1;
                if (!appState.clips.length) return 2;
                if (!appState.activeClipId) return 3;
                if (appState.captionsSource !== 'transcribed') return 4;
                if (appState.exportCount < 1 && appState.packCount < 1) return 5;
                return 5;
            }

            function workflowNextStepText(stage) {
                if (stage === 1) {
                    return 'Próximo passo: cole um link do YouTube (ou envie arquivo) e clique em Generate Clips.';
                }
                if (stage === 2) {
                    return 'Próximo passo: aguarde a geração e selecione o clip principal.';
                }
                if (stage === 3) {
                    return 'Próximo passo: abra o clip no editor para ajustar corte, título e estilo.';
                }
                if (stage === 4) {
                    const blockedReason = getTranscribeBlockingReason();
                    if (blockedReason) return `Próximo passo: transcrição bloqueada. ${blockedReason}`;
                    if (appState.sourceKind === 'youtube' || appState.sourceKind === 'link' || appState.sourceKind === 'ingested') {
                        return 'Próximo passo: transcrição automática já roda ao enviar link; use Reajustar para recalibrar legendas e cortes.';
                    }
                    return 'Próximo passo: clique em Reajustar para gerar legendas temporizadas com ElevenLabs.';
                }
                if (appState.exportCount > 0 || appState.packCount > 0) {
                    return 'Fluxo completo. Faça refinamentos e gere novas variações com comandos no chat.';
                }
                return 'Próximo passo: exporte o vídeo (Render Video) ou gere o pacote completo (Space Pack).';
            }

            function updateWorkflowGuide() {
                const hasSource = Boolean(appState.sourceSrc);
                const hasClips = appState.clips.length > 0;
                const hasActiveClip = Boolean(appState.activeClipId);
                const hasTranscribed = appState.captionsSource === 'transcribed';
                const hasDelivery = appState.exportCount > 0 || appState.packCount > 0;

                paintWorkflowCard(
                    wfSourceCard,
                    wfSourceState,
                    hasSource ? 'done' : 'active',
                    hasSource ? 'Concluído' : 'Em andamento'
                );
                paintWorkflowCard(
                    wfClipsCard,
                    wfClipsState,
                    hasClips ? 'done' : hasSource ? 'active' : 'pending',
                    hasClips ? `${appState.clips.length} gerados` : hasSource ? 'Gerando...' : 'Pendente'
                );
                paintWorkflowCard(
                    wfEditorCard,
                    wfEditorState,
                    hasActiveClip ? 'done' : hasClips ? 'active' : 'pending',
                    hasActiveClip ? 'Clip ativo' : hasClips ? 'Selecione 1 clip' : 'Pendente'
                );
                paintWorkflowCard(
                    wfCaptionCard,
                    wfCaptionState,
                    hasTranscribed ? 'done' : hasActiveClip ? 'active' : 'pending',
                    hasTranscribed ? 'Transcrição aplicada' : hasActiveClip ? 'Aguardando transcrever' : 'Pendente'
                );
                paintWorkflowCard(
                    wfDeliveryCard,
                    wfDeliveryState,
                    hasDelivery ? 'done' : hasActiveClip ? 'active' : 'pending',
                    hasDelivery ? 'Entregáveis prontos' : hasActiveClip ? 'Exportar / Pack' : 'Pendente'
                );

                const stage = computeCurrentStage();
                if (workflowStageBadge) {
                    workflowStageBadge.textContent = hasDelivery ? 'Etapa 5/5 (Completo)' : `Etapa ${stage}/5`;
                }
                if (workflowNextAction) workflowNextAction.textContent = workflowNextStepText(stage);

                guideOpenEditorBtn.disabled = !hasClips;
                guideTranscribeBtn.disabled = !hasClips;
                guideExportBtn.disabled = !hasActiveClip;
                guidePackBtn.disabled = !hasActiveClip;
            }

            async function refreshBackendHealth(force = false) {
                const now = Date.now();
                if (!force && appState.backend.checked && now - backendHealthLastCheckAt < 30000) {
                    return appState.backend;
                }
                if (backendHealthPromise && !force) return backendHealthPromise;

                backendHealthPromise = (async () => {
                    try {
                        let payload = null;
                        let resolvedHealthUrl = '';
                        let lastError = null;
                        const candidates = resolveHealthApiUrls();

                        for (const healthUrl of candidates) {
                            try {
                                const response = await fetchWithTimeout(healthUrl, {
                                    method: 'GET',
                                    cache: 'no-store'
                                }, 9000);
                                const maybePayload = await response.json().catch(() => ({}));
                                if (!response.ok) {
                                    if (response.status === 401 || response.status === 403) {
                                        throw new Error('Deploy protegido por autenticação. Faça login na Vercel ou desative Deployment Protection.');
                                    }
                                    throw new Error(maybePayload.error || `health endpoint retornou HTTP ${response.status}.`);
                                }
                                payload = maybePayload;
                                resolvedHealthUrl = healthUrl;
                                break;
                            } catch (error) {
                                lastError = error;
                            }
                        }

                        if (!payload) {
                            throw lastError || new Error('Nenhum endpoint de health respondeu.');
                        }

                        appState.backend.checked = true;
                        appState.backend.online = true;
                        appState.backend.hasElevenLabsKey = Boolean(payload.hasElevenLabsKey);
                        appState.backend.hasOpenAiKey = Boolean(payload.hasOpenAiKey);
                        appState.backend.hasYoutubeCookies = Boolean(payload.hasYoutubeCookies);
                        appState.backend.directTranscribeReady = Boolean(payload.directTranscribeReady);
                        appState.backend.youtubeTranscribeReady = Boolean(payload.youtubeTranscribeReady);
                        appState.backend.imageGenerationReady = Boolean(payload.imageGenerationReady);
                        appState.backend.videoEditReady = Boolean(payload.videoEditReady);
                        appState.backend.ytDlpAvailable = Boolean(payload.ytDlp?.available);
                        appState.backend.ytDlpBin = String(payload.ytDlp?.configured || payload.ytDlp?.command || '');
                        appState.backend.ffmpegAvailable = Boolean(payload.ffmpeg?.available);
                        appState.backend.ffmpegBin = String(payload.ffmpeg?.configured || payload.ffmpeg?.command || '');
                        appState.backend.runtime = String(payload.runtime || (isHostedDeploymentContext() ? 'serverless' : 'local-node'));
                        appState.backend.healthUrl = resolvedHealthUrl;
                        appState.backend.keyVaultReady = Boolean(payload.keyVaultReady);
                        appState.backend.error = '';

                        const problems = [];
                        if (!appState.backend.hasElevenLabsKey) {
                            problems.push(isHostedDeploymentContext() ? 'sem ELEVENLABS_API_KEY na Vercel' : 'sem ELEVENLABS_API_KEY');
                        }
                        if (appState.sourceKind === 'youtube' && !appState.backend.ytDlpAvailable) {
                            if (!isHostedDeploymentContext() && appState.backend.runtime !== 'serverless') {
                                problems.push('yt-dlp ausente para YouTube');
                            }
                        }
                        if (appState.sourceKind === 'youtube' && !appState.backend.hasYoutubeCookies && !getResolvedYoutubeCookies()) {
                            problems.push('YouTube cookies ausentes para vídeos protegidos por bot-check');
                        }
                        if (!appState.backend.videoEditReady && !isHostedDeploymentContext()) {
                            problems.push('ffmpeg ausente para patch/render runtime');
                        }
                        const backendLabel = isHostedDeploymentContext() ? 'Backend do deploy' : 'Backend local';
                        if (problems.length) {
                            setBackendStatus(`${backendLabel} online, mas com pendências: ${problems.join(' | ')}`, 'error');
                        } else {
                            setBackendStatus(`${backendLabel} online e pronto para transcrição/agent.`, 'success');
                        }
                    } catch (error) {
                        appState.backend.checked = true;
                        appState.backend.online = false;
                        appState.backend.hasElevenLabsKey = false;
                        appState.backend.hasOpenAiKey = false;
                        appState.backend.hasYoutubeCookies = false;
                        appState.backend.directTranscribeReady = false;
                        appState.backend.youtubeTranscribeReady = false;
                        appState.backend.imageGenerationReady = false;
                        appState.backend.videoEditReady = false;
                        appState.backend.ytDlpAvailable = false;
                        appState.backend.ffmpegAvailable = false;
                        appState.backend.ffmpegBin = '';
                        appState.backend.runtime = '';
                        appState.backend.healthUrl = '';
                        appState.backend.keyVaultReady = false;
                        appState.backend.error = error.message || 'Backend indisponível.';
                        setBackendStatus(getBackendOfflineInstruction(appState.backend.error), 'error');
                    } finally {
                        backendHealthLastCheckAt = Date.now();
                        backendHealthPromise = null;
                        updateWorkflowGuide();
                    }
                    return appState.backend;
                })();

                return backendHealthPromise;
            }

            async function resolveElevenAgentWebSocketUrl() {
                try {
                    const response = await fetchWithTimeout(resolveAgentSignedUrlApi(), {
                        method: 'GET',
                        cache: 'no-store'
                    }, 12000);
                    if (response.ok) {
                        const data = await response.json().catch(() => ({}));
                        if (data?.signed_url) return data.signed_url;
                    }
                } catch (_error) {
                    // fallback to public URL below
                }
                return `wss://api.elevenlabs.io/v1/convai/conversation?agent_id=${encodeURIComponent(appState.elevenAgentId || '')}`;
            }

            function handleElevenAgentMessage(event) {
                let payload;
                try {
                    payload = JSON.parse(event.data);
                } catch (_error) {
                    return;
                }

                if (payload.type === 'ping' && elevenAgentSocket && elevenAgentSocket.readyState === WebSocket.OPEN) {
                    const pongEventId = payload.ping_event?.event_id;
                    elevenAgentSocket.send(JSON.stringify({ type: 'pong', event_id: pongEventId }));
                    return;
                }

                if (payload.type === 'agent_response' || payload.type === 'agent_response_correction') {
                    const text = String(payload.agent_response_event?.agent_response || payload.agent_response_correction_event?.corrected_response || '').trim();
                    if (!text) return;
                    if (elevenAgentPendingResolver) {
                        const resolver = elevenAgentPendingResolver;
                        elevenAgentPendingResolver = null;
                        resolver.resolve(text);
                        return;
                    }
                    addChatMessage('assistant', `[Agent] ${text}`);
                }
            }

            async function connectElevenAgentSocket() {
                if (!appState.elevenAgentId) {
                    throw new Error('Agent ID ausente.');
                }

                if (elevenAgentSocket && elevenAgentSocket.readyState === WebSocket.OPEN) {
                    return elevenAgentSocket;
                }
                if (elevenAgentConnectPromise) return elevenAgentConnectPromise;

                elevenAgentConnectPromise = new Promise(async (resolve, reject) => {
                    let ws;
                    let timeout;
                    try {
                        const url = await resolveElevenAgentWebSocketUrl();
                        ws = new WebSocket(url);
                    } catch (error) {
                        reject(error);
                        return;
                    }

                    timeout = setTimeout(() => {
                        try {
                            ws.close();
                        } catch (_error) {
                            // noop
                        }
                        reject(new Error('Timeout ao conectar no Agent.'));
                    }, 12000);

                    ws.onopen = () => {
                        clearTimeout(timeout);
                        elevenAgentSocket = ws;
                        setAgentStatus('Agent connected.', 'success');
                        agentConnectBtn.textContent = 'Disconnect Agent';
                        try {
                            ws.send(JSON.stringify({
                                type: 'conversation_initiation_client_data',
                                conversation_config_override: {
                                    agent: { prompt: { prompt: 'You help editing short-form videos and captions.' } }
                                }
                            }));
                        } catch (_error) {
                            // noop
                        }
                        resolve(ws);
                    };

                    ws.onmessage = handleElevenAgentMessage;
                    ws.onerror = () => {
                        setAgentStatus('Falha na conexão do Agent.', 'error');
                    };
                    ws.onclose = () => {
                        if (elevenAgentSocket === ws) {
                            elevenAgentSocket = null;
                        }
                        if (elevenAgentPendingResolver) {
                            elevenAgentPendingResolver.reject(new Error('Agent disconnected before responding.'));
                            elevenAgentPendingResolver = null;
                        }
                        setAgentStatus('Agent disconnected.', 'muted');
                        agentConnectBtn.textContent = 'Connect Agent';
                    };
                }).catch((error) => {
                    setAgentStatus(error.message || 'Não foi possível conectar ao Agent.', 'error');
                    throw error;
                }).finally(() => {
                    elevenAgentConnectPromise = null;
                });

                return elevenAgentConnectPromise;
            }

            function disconnectElevenAgentSocket() {
                if (elevenAgentSocket) {
                    try {
                        elevenAgentSocket.close();
                    } catch (_error) {
                        // noop
                    }
                    elevenAgentSocket = null;
                }
            }

            async function askElevenAgent(message) {
                const text = String(message || '').trim();
                if (!text || !appState.elevenAgentId) return null;

                let ws;
                try {
                    ws = await connectElevenAgentSocket();
                } catch (_error) {
                    return null;
                }

                if (!ws || ws.readyState !== WebSocket.OPEN) return null;
                if (elevenAgentPendingResolver) return null;

                return await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        if (elevenAgentPendingResolver) {
                            elevenAgentPendingResolver = null;
                        }
                        reject(new Error('Agent response timeout.'));
                    }, 15000);

                    elevenAgentPendingResolver = {
                        resolve: (value) => {
                            clearTimeout(timeout);
                            resolve(value);
                        },
                        reject: (error) => {
                            clearTimeout(timeout);
                            reject(error);
                        }
                    };

                    try {
                        ws.send(JSON.stringify({ type: 'user_message', text }));
                        ws.send(JSON.stringify({ type: 'user_activity' }));
                    } catch (error) {
                        if (elevenAgentPendingResolver) {
                            elevenAgentPendingResolver = null;
                        }
                        clearTimeout(timeout);
                        reject(error);
                    }
                }).catch(() => null);
            }

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onerror = () => reject(new Error('Falha ao ler arquivo para transcrição.'));
                    reader.onload = () => {
                        const value = String(reader.result || '');
                        const base64 = value.includes(',') ? value.split(',')[1] : value;
                        resolve(base64);
                    };
                    reader.readAsDataURL(blob);
                });
            }

            function encodeBase64Utf8(value) {
                const text = String(value || '');
                if (!text) return '';
                try {
                    return btoa(unescape(encodeURIComponent(text)));
                } catch (_error) {
                    return '';
                }
            }

            async function getMediaBlobForTranscription() {
                if (appState.sourceKind === 'upload' && fileInput.files.length > 0) {
                    return fileInput.files[0];
                }

                if (appState.sourceKind === 'ingested' && appState.ingestedMediaBlob instanceof Blob) {
                    return appState.ingestedMediaBlob;
                }

                if (appState.sourceKind === 'link') {
                    let response;
                    try {
                        response = await fetchWithTimeout(appState.sourceSrc, { mode: 'cors' }, 45000);
                    } catch (_error) {
                        throw new Error('Falha ao baixar o vídeo do link para transcrever. Tente upload de arquivo.');
                    }
                    if (!response.ok) {
                        throw new Error('Não foi possível baixar a mídia para transcrição.');
                    }
                    return await response.blob();
                }

                throw new Error('Nenhuma fonte de vídeo ativa para transcrição.');
            }

            async function buildTranscribeRequestPayload() {
                if (appState.sourceKind === 'youtube') {
                    const payload = {
                        youtubeUrl: appState.sourceSrc,
                        modelId: 'scribe_v1',
                        allowSyntheticFallback: false
                    };
                    const youtubeCookies = getResolvedYoutubeCookies();
                    const youtubeCookiesBase64 = encodeBase64Utf8(youtubeCookies);
                    if (youtubeCookiesBase64) payload.youtubeCookiesBase64 = youtubeCookiesBase64;
                    return payload;
                }

                const mediaBlob = await getMediaBlobForTranscription();
                const base64Data = await blobToBase64(mediaBlob);
                return {
                    fileName: mediaBlob.name || `source-${Date.now()}.mp4`,
                    mimeType: mediaBlob.type || 'video/mp4',
                    base64Data,
                    modelId: 'scribe_v1'
                };
            }

            function extractWordsFromTranscribeResponse(payload) {
                if (Array.isArray(payload.words) && payload.words.length) return payload.words;
                if (Array.isArray(payload.segments) && payload.segments.length) {
                    return payload.segments.flatMap((segment) => {
                        if (!Array.isArray(segment.words)) return [];
                        return segment.words;
                    });
                }
                return [];
            }

            function normalizeWordEntry(word, fallbackStart = 0, fallbackEnd = 0) {
                const text = String(word.word || word.text || word.token || '').trim();
                const start = Number(word.start ?? word.start_time ?? word.startTime ?? fallbackStart);
                const end = Number(word.end ?? word.end_time ?? word.endTime ?? fallbackEnd);
                if (!text) return null;
                return {
                    text,
                    start: Number.isFinite(start) ? start : fallbackStart,
                    end: Number.isFinite(end) ? end : Math.max(fallbackStart + 0.2, fallbackEnd)
                };
            }

            function buildCaptionsFromWordsForClip(clip, words) {
                const clipWords = words
                    .filter((word) => Number.isFinite(word.start) && Number.isFinite(word.end))
                    .filter((word) => word.end >= clip.start && word.start <= clip.end)
                    .sort((a, b) => a.start - b.start);

                if (!clipWords.length) {
                    return buildCaptions(clip, clipThemes[0]);
                }

                const captions = [];
                let lineWords = [];
                let lineStart = clipWords[0].start;
                let lineEnd = clipWords[0].end;

                const flushLine = () => {
                    if (!lineWords.length) return;
                    const text = lineWords.join(' ').replace(/\s+/g, ' ').trim();
                    captions.push({
                        id: `${clip.id}-caption-${captions.length + 1}`,
                        time: roundTenth(clamp(lineStart, clip.start, clip.end)),
                        text
                    });
                    lineWords = [];
                };

                clipWords.forEach((word, index) => {
                    const candidateWords = [...lineWords, word.text];
                    const candidateText = candidateWords.join(' ');
                    const nextGap = index > 0 ? word.start - lineEnd : 0;
                    const lineDuration = word.end - lineStart;
                    const shouldBreak = candidateText.length > 42 || lineDuration > 2.4 || nextGap > 0.55;

                    if (shouldBreak && lineWords.length) {
                        flushLine();
                        lineStart = word.start;
                    }

                    if (!lineWords.length) lineStart = word.start;
                    lineWords.push(word.text);
                    lineEnd = word.end;
                });

                flushLine();
                return captions.slice(0, 40);
            }

            function syncClipCaptionsToTranscript(clip) {
                if (!clip || appState.captionsSource !== 'transcribed') return;
                if (!Array.isArray(appState.transcriptWords) || !appState.transcriptWords.length) return;
                clip.captions = buildCaptionsFromWordsForClip(clip, appState.transcriptWords);
                enrichClipMetadata(clip, clip.theme || clipThemes[0]?.title || 'General');
            }

            async function transcribeWithElevenLabs() {
                const payload = await buildTranscribeRequestPayload();

                let response;
                try {
                    response = await fetchWithTimeout(resolveTranscribeApiUrl(), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }, 180000);
                } catch (_error) {
                    throw new Error(
                        isHostedDeploymentContext()
                            ? 'Falha de conexão com o backend de transcrição no deploy.'
                            : 'Falha de conexão com o serviço local de transcrição (porta 8787).'
                    );
                }

                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(data.error || 'Erro ao transcrever com ElevenLabs.');
                }

                if (String(data.source || '').trim() === 'youtube_synthetic_fallback') {
                    throw new Error('O backend retornou fallback sintético (sem áudio/captions reais). Verifique se o vídeo está público e confirme o ID exato da URL.');
                }

                return data;
            }

            async function handleTranscribeCaptions(options = {}) {
                const automatic = Boolean(options.automatic);
                if (!appState.clips.length) {
                    setTranscribeStatus('Gere os clips antes de transcrever.', 'error');
                    updateWorkflowGuide();
                    return;
                }

                if (appState.transcribeInFlight) return;

                await refreshBackendHealth(false);
                const transcribeBlock = getTranscribeBlockingReason();
                if (transcribeBlock) {
                    setTranscribeStatus(transcribeBlock, 'error');
                    if (!automatic) addChatMessage('assistant', transcribeBlock);
                    updateWorkflowGuide();
                    return;
                }

                if (transcribeCaptionsBtn.disabled && !automatic) return;
                const original = transcribeCaptionsBtn.innerHTML;
                appState.transcribeInFlight = true;
                transcribeCaptionsBtn.disabled = true;
                transcribeCaptionsBtn.innerHTML = automatic
                    ? '<iconify-icon icon="solar:spinner-linear" class="animate-spin"></iconify-icon> Auto...'
                    : '<iconify-icon icon="solar:spinner-linear" class="animate-spin"></iconify-icon> Reajustando...';
                if (automatic) {
                    setTranscribeStatus('Link recebido. Transcrevendo automaticamente e encaixando captions nos cortes...', 'muted');
                } else if (appState.sourceKind === 'youtube') {
                    setTranscribeStatus('Reajustando captions via transcrição do YouTube...', 'muted');
                } else {
                    setTranscribeStatus('Reajustando captions com STT...', 'muted');
                }

                try {
                    const result = await transcribeWithElevenLabs();
                    const rawWords = extractWordsFromTranscribeResponse(result);
                    const words = rawWords
                        .map((word) => normalizeWordEntry(word))
                        .filter(Boolean);

                    if (!words.length) {
                        throw new Error('A API não retornou timestamps de palavras para gerar legendas.');
                    }

                    appState.transcriptWords = words;
                    appState.clips = appState.clips.map((clip) => {
                        const captions = buildCaptionsFromWordsForClip(clip, words);
                        return enrichClipMetadata({ ...clip, captions }, clip.theme || clipThemes[0]?.title || 'General');
                    });
                    appState.captionsSource = 'transcribed';
                    appState.activeThemeFilter = 'all';
                    appState.activeSubjectFilter = 'all';

                    const active = getActiveClip();
                    if (active) {
                        renderCaptions(active);
                        updateCaptionPreviewText();
                    }
                    switchEditorTab('captions');
                    renderClipGrid();
                    applyFilter(appState.activeFilter);

                    const warning = String(result.warning || '').trim();
                    const statusMsg = `Transcrição concluída: ${words.length} palavras mapeadas para ${appState.clips.length} clips.${warning ? ` Aviso: ${warning}` : ''}`;
                    setTranscribeStatus(statusMsg, 'success');
                    setEditorStatus('Legendas atualizadas com transcrição ElevenLabs.', 'success');
                    if (automatic) {
                        addChatMessage('assistant', 'Transcrição automática concluída. As captions já foram sincronizadas com todos os cortes.');
                    } else {
                        addChatMessage('assistant', 'Reajuste concluído. As captions foram resincronizadas com os cortes.');
                    }
                } catch (error) {
                    const rawMessage = String(error && error.message ? error.message : 'Falha ao transcrever.');
                    const needsCookiesHint = /sign in to confirm you'?re not a bot|bot-check/i.test(rawMessage);
                    const hasLocalCookies = Boolean(getResolvedYoutubeCookies());
                    const message = needsCookiesHint && !hasLocalCookies
                        ? `${rawMessage} Dica: abra "YouTube cookies" na aba Captions, cole os cookies e tente novamente.`
                        : rawMessage;
                    setTranscribeStatus(message, 'error');
                } finally {
                    appState.transcribeInFlight = false;
                    transcribeCaptionsBtn.disabled = false;
                    transcribeCaptionsBtn.innerHTML = original;
                    updateWorkflowGuide();
                }
            }

            function formatTime(totalSeconds) {
                const seconds = Math.max(0, Number.isFinite(totalSeconds) ? totalSeconds : 0);
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function roundTenth(value) {
                return Math.round(value * 10) / 10;
            }

            function slugify(value) {
                return String(value || 'clip')
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/(^-|-$)+/g, '')
                    .slice(0, 60) || 'clip';
            }

            function cleanupObjectUrl() {
                if (appState.objectUrl) {
                    URL.revokeObjectURL(appState.objectUrl);
                    appState.objectUrl = null;
                }
                appState.ingestedMediaBlob = null;
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function hexToRgb(hex) {
                const normalized = String(hex || '').replace('#', '');
                if (!/^[a-fA-F0-9]{6}$/.test(normalized)) return { r: 0, g: 0, b: 0 };
                return {
                    r: parseInt(normalized.slice(0, 2), 16),
                    g: parseInt(normalized.slice(2, 4), 16),
                    b: parseInt(normalized.slice(4, 6), 16)
                };
            }

            function applyCase(text, textCase) {
                if (textCase === 'uppercase') return text.toUpperCase();
                if (textCase === 'lowercase') return text.toLowerCase();
                return text;
            }

            function escapeHtml(value) {
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }

            const SUBJECT_STOPWORDS = new Set([
                'about', 'after', 'again', 'algo', 'alguma', 'algumas', 'algum', 'alguns', 'antes', 'aqui', 'assim',
                'bem', 'cada', 'como', 'com', 'contra', 'coisa', 'coisas', 'desde', 'depois', 'dos', 'das',
                'essa', 'essas', 'esse', 'esses', 'esta', 'estas', 'este', 'estes', 'estao', 'está', 'estão',
                'fazer', 'fazendo', 'for', 'from', 'have', 'isso', 'isto', 'mais', 'mas', 'mesmo', 'muito',
                'nada', 'nao', 'não', 'nos', 'nós', 'num', 'numa', 'onde', 'para', 'porque', 'quando',
                'sobre', 'sem', 'seu', 'sua', 'suas', 'seus', 'that', 'this', 'uma', 'umas', 'uns', 'with',
                'você', 'voce', 'your', 'you', 'the', 'and', 'are', 'was', 'were', 'what', 'which', 'will',
                'por', 'pra', 'pro', 'dos', 'das', 'nosso', 'nossa', 'nossos', 'nossas'
            ]);

            function toFilterId(value, fallback = 'geral') {
                const normalized = String(value || '')
                    .trim()
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '')
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '');
                return normalized || fallback;
            }

            function toTitleCase(label) {
                return String(label || '')
                    .trim()
                    .split(/\s+/)
                    .filter(Boolean)
                    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
            }

            function extractSubjectTokens(rawText) {
                const clean = String(rawText || '')
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '')
                    .replace(/[^a-z0-9\s]/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                if (!clean) return [];
                return clean
                    .split(' ')
                    .filter((token) => token.length >= 3 && !SUBJECT_STOPWORDS.has(token));
            }

            function inferClipSubjectFromText(rawText) {
                const tokens = extractSubjectTokens(rawText);
                if (!tokens.length) {
                    return { id: 'geral', label: 'Geral' };
                }

                const counts = new Map();
                tokens.forEach((token) => {
                    counts.set(token, (counts.get(token) || 0) + 1);
                });

                const ranked = Array.from(counts.entries())
                    .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
                    .map(([token]) => token);

                const top = ranked.slice(0, 2);
                const label = toTitleCase(top.join(' '));
                const id = toFilterId(top.join('-'), 'geral');
                return { id, label: label || 'Geral' };
            }

            function enrichClipMetadata(clip, fallbackTheme = '') {
                if (!clip || typeof clip !== 'object') return clip;
                const fallbackThemeLabel = String(fallbackTheme || 'General').trim();
                const themeLabel = String(clip.theme || fallbackThemeLabel || 'General').trim() || 'General';
                clip.theme = themeLabel;
                clip.themeId = toFilterId(themeLabel, 'general');

                const captionText = Array.isArray(clip.captions)
                    ? clip.captions.map((caption) => String(caption.text || '').trim()).join(' ')
                    : '';
                const subject = inferClipSubjectFromText(captionText || `${clip.title || ''} ${clip.hook || ''}`);
                clip.subjectId = subject.id;
                clip.subject = subject.label;
                return clip;
            }

            function refreshClipMetadataFromCaptions() {
                appState.clips = appState.clips.map((clip, index) => {
                    const fallbackTheme = clipThemes[index % clipThemes.length]?.title || 'General';
                    return enrichClipMetadata(clip, fallbackTheme);
                });
            }

            function fillSelectOptions(selectEl, options, selectedValue = 'all') {
                if (!selectEl) return;
                const values = [];
                const seen = new Set();
                (Array.isArray(options) ? options : []).forEach((entry) => {
                    if (!entry || !entry.id) return;
                    const id = String(entry.id);
                    if (seen.has(id)) return;
                    seen.add(id);
                    values.push({ id, label: String(entry.label || id) });
                });
                selectEl.innerHTML = ['<option value="all">Todos</option>', ...values.map((entry) => {
                    const label = escapeHtml(entry.label);
                    const value = escapeHtml(entry.id);
                    return `<option value="${value}">${label}</option>`;
                })].join('');
                const hasCurrent = values.some((entry) => entry.id === selectedValue);
                selectEl.value = hasCurrent ? selectedValue : 'all';
            }

            function updateThemeSubjectFilterOptions() {
                const themeOptions = appState.clips.map((clip) => ({
                    id: String(clip.themeId || 'general'),
                    label: String(clip.theme || 'General')
                }));
                fillSelectOptions(themeFilterSelect, themeOptions, appState.activeThemeFilter);
                appState.activeThemeFilter = themeFilterSelect ? themeFilterSelect.value : 'all';

                const subjectOptions = appState.clips.map((clip) => ({
                    id: String(clip.subjectId || 'geral'),
                    label: String(clip.subject || 'Geral')
                }));
                fillSelectOptions(subjectFilterSelect, subjectOptions, appState.activeSubjectFilter);
                appState.activeSubjectFilter = subjectFilterSelect ? subjectFilterSelect.value : 'all';
            }

            function ensureClipEditData(clip) {
                if (!clip || typeof clip !== 'object') return clip;
                if (!Number.isFinite(clip.baseStart)) clip.baseStart = roundTenth(Number(clip.start) || 0);
                if (!Number.isFinite(clip.baseEnd)) clip.baseEnd = roundTenth(Number(clip.end) || Math.max(0.2, clip.baseStart + 12));
                if (!clip.crop || typeof clip.crop !== 'object') clip.crop = { zoom: 100, x: 0, y: 0 };
                clip.crop.zoom = clamp(Number(clip.crop.zoom) || 100, 100, 180);
                clip.crop.x = clamp(Number(clip.crop.x) || 0, -40, 40);
                clip.crop.y = clamp(Number(clip.crop.y) || 0, -40, 40);
                if (!Array.isArray(clip.overlays)) clip.overlays = [];
                if (!Array.isArray(clip.fillerShots)) clip.fillerShots = [];
                clip.fillerShots = clip.fillerShots
                    .map((shot, index) => {
                        const start = clamp(Number(shot.start), clip.start, clip.end);
                        const end = clamp(Number(shot.end), start + 0.2, clip.end);
                        const src = String(shot.src || shot.imageUrl || '').trim();
                        if (!src) return null;
                        return {
                            id: String(shot.id || `fill-${Date.now()}-${index}`),
                            start: roundTenth(start),
                            end: roundTenth(end),
                            src,
                            prompt: String(shot.prompt || '').trim()
                        };
                    })
                    .filter(Boolean);
                return clip;
            }

            function switchEditorTab(tabName) {
                const tab = ['captions', 'audio', 'styles', 'complement'].includes(tabName) ? tabName : 'captions';
                appState.complement.tab = tab;

                editorTabBtns.forEach((btn) => {
                    const isActive = btn.dataset.editorTab === tab;
                    btn.classList.toggle('text-accent', isActive);
                    btn.classList.toggle('border-b-2', isActive);
                    btn.classList.toggle('border-accent', isActive);
                    btn.classList.toggle('text-white/50', !isActive);
                });

                const showComplement = tab === 'complement';
                if (complementPanel) complementPanel.classList.toggle('hidden', !showComplement);
                editorMainPanels.forEach((panel) => {
                    panel.classList.toggle('hidden', showComplement);
                });

                if (showComplement) {
                    renderComplementImageList();
                    return;
                }

                if (tab === 'audio' && audioMixSection) {
                    audioMixSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else if (tab === 'styles' && captionStyleSection) {
                    captionStyleSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else if (tab === 'captions' && commandChatSection) {
                    commandChatSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            function getEffectiveComplementApiKey() {
                const typed = String(complementApiKeyInput.value || '').trim();
                return typed || String(appState.complement.apiKey || '').trim();
            }

            async function requestComplementImage(prompt, model = 'gpt-image-1', size = '1024x1024') {
                const payload = {
                    provider: appState.complement.provider || 'openai',
                    model,
                    size,
                    prompt
                };
                const key = getEffectiveComplementApiKey();
                if (key) payload.apiKey = key;

                const response = await fetchWithTimeout(resolveComplementImageApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, 180000);

                const raw = await response.text();
                let data;
                try {
                    data = JSON.parse(raw);
                } catch (_error) {
                    data = { error: raw || 'Resposta inválida do backend de imagem.' };
                }

                if (!response.ok) {
                    throw new Error(data.error || 'Falha ao gerar imagem complementar.');
                }
                const src = String(data.imageDataUrl || data.imageUrl || '').trim();
                if (!src) {
                    throw new Error('A geração não retornou URL/base64 de imagem.');
                }
                return { src, payload: data };
            }

            function upsertClipFillerShot(clip, shotInput) {
                const target = ensureClipEditData(clip);
                if (!target) return null;
                const start = clamp(Number(shotInput.start), target.start, target.end - 0.2);
                const end = clamp(Number(shotInput.end), start + 0.2, target.end);
                const shot = {
                    id: String(shotInput.id || `fill-${Date.now()}-${Math.round(Math.random() * 10000)}`),
                    start: roundTenth(start),
                    end: roundTenth(end),
                    src: String(shotInput.src || '').trim(),
                    prompt: String(shotInput.prompt || '').trim()
                };
                if (!shot.src) return null;
                target.fillerShots.push(shot);
                target.fillerShots.sort((a, b) => a.start - b.start);
                return shot;
            }

            function buildPromptForGap(clip, gap, userIntent = '') {
                const transcriptContext = getClipTranscriptContext(clip);
                const localContext = String(gap?.context || '').trim();
                const context = `${transcriptContext} ${localContext}`.trim();
                return buildAttentionImagePrompt(context, userIntent);
            }

            async function generateSingleComplementFromPrompt(rawPrompt) {
                const clip = getActiveClip();
                if (!clip) throw new Error('Selecione um clip antes de gerar complemento.');
                const prompt = buildPromptForGap(clip, { context: getClipTranscriptContext(clip) }, rawPrompt);
                const playhead = getPlaybackCurrentTime();
                const start = Number.isFinite(playhead)
                    ? clamp(playhead, clip.start, Math.max(clip.start, clip.end - 2.2))
                    : clip.start;
                const end = clamp(start + 2.2, start + 0.2, clip.end);
                const image = await requestComplementImage(prompt);
                const shot = upsertClipFillerShot(clip, {
                    start,
                    end,
                    src: image.src,
                    prompt
                });
                if (!shot) throw new Error('Falha ao anexar filler no clip.');
                applyClipVisualTransform();
                renderComplementImageList();
                return shot;
            }

            async function generateComplementForSpeechGaps({ regenerate = false } = {}) {
                const clip = getActiveClip();
                if (!clip) {
                    setComplementStatus('Selecione um clip antes de gerar preenchimento.', 'error');
                    return;
                }
                if (appState.complement.busy) return;

                appState.complement.busy = true;
                complementAutoFillBtn.disabled = true;
                complementRegenerateBtn.disabled = true;
                setComplementStatus('Analisando gaps e gerando imagens...', 'muted');

                try {
                    ensureClipEditData(clip);
                    if (regenerate) {
                        clip.fillerShots = [];
                    }
                    let gaps = collectSpeechGapsForClip(clip, 1.4);
                    if (!gaps.length) {
                        const fallbackStart = roundTenth(clamp(clip.start + Math.max(0, (clip.end - clip.start) * 0.35), clip.start, clip.end - 2.2));
                        gaps = [{
                            start: fallbackStart,
                            end: roundTenth(clamp(fallbackStart + 2.2, fallbackStart + 0.2, clip.end)),
                            context: getClipTranscriptContext(clip)
                        }];
                    }

                    const targetGaps = gaps.slice(0, 3);
                    for (let index = 0; index < targetGaps.length; index += 1) {
                        const gap = targetGaps[index];
                        const prompt = buildPromptForGap(clip, gap, 'attention-grabbing filler shot that fits narration');
                        const image = await requestComplementImage(prompt);
                        upsertClipFillerShot(clip, {
                            start: gap.start,
                            end: gap.end,
                            src: image.src,
                            prompt
                        });
                        setComplementStatus(`Imagem ${index + 1}/${targetGaps.length} gerada.`, 'muted');
                    }

                    applyClipVisualTransform();
                    renderComplementImageList();
                    setComplementStatus(`Pronto: ${targetGaps.length} preenchimentos adicionados.`, 'success');
                    addComplementMessage('assistant', `Gerei ${targetGaps.length} imagens contextuais para os espaços sem fala.`);
                } catch (error) {
                    setComplementStatus(error.message || 'Falha ao gerar complementos.', 'error');
                    addComplementMessage('assistant', error.message || 'Falha ao gerar complementos.');
                } finally {
                    appState.complement.busy = false;
                    complementAutoFillBtn.disabled = false;
                    complementRegenerateBtn.disabled = false;
                }
            }

            async function runComplementChat(rawInput) {
                const text = String(rawInput || '').trim();
                if (!text) return;
                addComplementMessage('user', text);

                const normalized = normalizeCommand(text);
                if (normalized.includes('gaps') || normalized.includes('lacuna') || normalized.includes('espaco vazio') || normalized.includes('espaço vazio')) {
                    await generateComplementForSpeechGaps({ regenerate: false });
                    return;
                }
                if (normalized.includes('regenerar') || normalized.includes('refazer')) {
                    await generateComplementForSpeechGaps({ regenerate: true });
                    return;
                }

                try {
                    setComplementStatus('Gerando imagem complementar para o contexto atual...', 'muted');
                    const shot = await generateSingleComplementFromPrompt(text);
                    setComplementStatus('Imagem complementar adicionada no playhead.', 'success');
                    addComplementMessage('assistant', `Imagem adicionada em ${formatTime(shot.start)}-${formatTime(shot.end)}.`);
                } catch (error) {
                    setComplementStatus(error.message || 'Falha ao gerar imagem.', 'error');
                    addComplementMessage('assistant', error.message || 'Falha ao gerar imagem.');
                }
            }

            function buildDefaultAutomationNodes() {
                return {
                    trigger_new_video: {
                        id: 'trigger_new_video',
                        type: 'TRIGGER',
                        title: 'New video ingested',
                        baseSubtitle: 'Source: clip library',
                        delayMinutes: 0,
                        preset: 'balanced',
                        autoThumb: false,
                        autoHashtags: false
                    },
                    action_detect_cuts: {
                        id: 'action_detect_cuts',
                        type: 'ACTION',
                        title: 'Detect best cuts',
                        baseSubtitle: 'Score + timing map',
                        delayMinutes: 2,
                        preset: 'balanced',
                        autoThumb: false,
                        autoHashtags: false
                    },
                    action_captions: {
                        id: 'action_captions',
                        type: 'ACTION',
                        title: 'Generate captions',
                        baseSubtitle: 'Model: scribe_v1',
                        delayMinutes: 4,
                        preset: 'balanced',
                        autoThumb: false,
                        autoHashtags: false
                    },
                    logic_review_wait: {
                        id: 'logic_review_wait',
                        type: 'LOGIC',
                        title: 'Wait review',
                        baseSubtitle: 'Duration: 10m',
                        delayMinutes: 10,
                        preset: 'balanced',
                        autoThumb: false,
                        autoHashtags: false
                    },
                    action_publish_pack: {
                        id: 'action_publish_pack',
                        type: 'ACTION',
                        title: 'Publish pack',
                        baseSubtitle: 'Thumb + titles + hashtags',
                        delayMinutes: 1,
                        preset: 'bold',
                        autoThumb: true,
                        autoHashtags: true
                    }
                };
            }

            function ensureAutomationState() {
                if (!appState.automation || typeof appState.automation !== 'object') {
                    appState.automation = {
                        selectedNodeId: 'trigger_new_video',
                        successRate: 99.1,
                        nodes: {},
                        templates: [],
                        ingest: null,
                        patchLayers: [],
                        renderPlan: null,
                        lastPatchResult: null,
                        lastRenderResult: null
                    };
                }
                if (!appState.automation.nodes || !Object.keys(appState.automation.nodes).length) {
                    appState.automation.nodes = buildDefaultAutomationNodes();
                }
                if (!Number.isFinite(appState.automation.successRate)) appState.automation.successRate = 99.1;
                if (!Array.isArray(appState.automation.templates)) appState.automation.templates = [];
                if (!Array.isArray(appState.automation.patchLayers)) appState.automation.patchLayers = [];
                if (!Object.prototype.hasOwnProperty.call(appState.automation, 'ingest')) appState.automation.ingest = null;
                if (!Object.prototype.hasOwnProperty.call(appState.automation, 'renderPlan')) appState.automation.renderPlan = null;
                if (!Object.prototype.hasOwnProperty.call(appState.automation, 'lastPatchResult')) appState.automation.lastPatchResult = null;
                if (!Object.prototype.hasOwnProperty.call(appState.automation, 'lastRenderResult')) appState.automation.lastRenderResult = null;
                if (!appState.automation.selectedNodeId || !appState.automation.nodes[appState.automation.selectedNodeId]) {
                    appState.automation.selectedNodeId = 'trigger_new_video';
                }
            }

            function getAutomationNode(nodeId) {
                ensureAutomationState();
                return appState.automation.nodes[nodeId] || null;
            }

            function automationNodeSubtitle(node) {
                if (!node) return '';
                const parts = [];
                if (node.type === 'LOGIC') {
                    parts.push(`Duration: ${clamp(Number(node.delayMinutes) || 0, 0, 1440)}m`);
                } else if (node.type !== 'TRIGGER') {
                    parts.push(`Delay ${clamp(Number(node.delayMinutes) || 0, 0, 1440)}m`);
                }
                if (node.type === 'ACTION') parts.push(`Preset ${node.preset || 'balanced'}`);
                if (node.autoThumb) parts.push('thumb');
                if (node.autoHashtags) parts.push('hashtags');
                return parts.length ? parts.join(' · ') : (node.baseSubtitle || '');
            }

            function setAutomationPromptStatus(message, tone = 'muted') {
                if (!automationPromptStatus) return;
                automationPromptStatus.textContent = message || '';
                automationPromptStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') automationPromptStatus.classList.add('text-red-300');
                else if (tone === 'success') automationPromptStatus.classList.add('text-accent');
                else automationPromptStatus.classList.add('text-white/40');
            }

            function setAutomationInfraStatus(message, tone = 'muted') {
                if (!automationInfraStatus) return;
                automationInfraStatus.textContent = message || '';
                automationInfraStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') automationInfraStatus.classList.add('text-red-300');
                else if (tone === 'success') automationInfraStatus.classList.add('text-accent');
                else automationInfraStatus.classList.add('text-white/40');
            }

            function appendAutomationInfraLog(message, tone = 'neutral') {
                if (!automationInfraLog) return;
                const item = document.createElement('div');
                const colorClass = tone === 'error'
                    ? 'text-red-300'
                    : tone === 'success'
                        ? 'text-accent'
                        : 'text-white/70';
                item.className = `leading-relaxed ${colorClass}`;
                item.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                automationInfraLog.prepend(item);
                while (automationInfraLog.children.length > 24) {
                    automationInfraLog.removeChild(automationInfraLog.lastChild);
                }
            }

            function renderAutomationNodesUi() {
                ensureAutomationState();
                automarNodeButtons.forEach((button) => {
                    const nodeId = button.dataset.automarNode;
                    const node = getAutomationNode(nodeId);
                    if (!node) return;
                    const titleNode = button.querySelector('.automar-node-title');
                    const subtitleNode = button.querySelector('.automar-node-subtitle');
                    if (titleNode) titleNode.textContent = node.title;
                    if (subtitleNode) subtitleNode.textContent = automationNodeSubtitle(node);

                    const selected = appState.automation.selectedNodeId === nodeId;
                    button.classList.remove('border-accent/40', 'bg-accent/[0.08]', 'shadow-[0_0_18px_rgba(200,255,0,0.18)]');
                    if (selected) {
                        button.classList.add('border-accent/40', 'bg-accent/[0.08]', 'shadow-[0_0_18px_rgba(200,255,0,0.18)]');
                    }
                });

                if (automationNodesCount) automationNodesCount.textContent = String(Object.keys(appState.automation.nodes).length);
                if (automationSuccessRate) automationSuccessRate.textContent = `${appState.automation.successRate.toFixed(1)}%`;
            }

            function syncAutomationNodePanel() {
                const node = getAutomationNode(appState.automation.selectedNodeId);
                if (!node) return;
                automationSelectedNodeLabel.textContent = node.title;
                automationNodeTypeBadge.textContent = node.type;
                automationNodeNameInput.value = node.title;
                automationNodeDelayInput.value = String(clamp(Number(node.delayMinutes) || 0, 0, 1440));
                automationNodePresetSelect.value = node.preset || 'balanced';
                automationNodeAutoThumb.checked = Boolean(node.autoThumb);
                automationNodeAutoHashtags.checked = Boolean(node.autoHashtags);
            }

            function selectAutomationNode(nodeId) {
                if (!getAutomationNode(nodeId)) return;
                appState.automation.selectedNodeId = nodeId;
                renderAutomationNodesUi();
                syncAutomationNodePanel();
            }

            function saveAutomationNodeConfig() {
                const node = getAutomationNode(appState.automation.selectedNodeId);
                if (!node) return;

                const nextName = automationNodeNameInput.value.trim();
                node.title = nextName || node.title;
                node.delayMinutes = clamp(parseInt(automationNodeDelayInput.value, 10) || 0, 0, 1440);
                node.preset = automationNodePresetSelect.value || 'balanced';
                node.autoThumb = Boolean(automationNodeAutoThumb.checked);
                node.autoHashtags = Boolean(automationNodeAutoHashtags.checked);

                renderAutomationNodesUi();
                syncAutomationNodePanel();
                setAutomationPromptStatus('Configuração do node salva.', 'success');
                appendSpaceOutput(`[Automar] ${node.title} atualizado.`, 'success');
            }

            async function applyAutomationPrompt() {
                const prompt = String(automationPromptInput.value || '').trim();
                if (!prompt) {
                    setAutomationPromptStatus('Digite uma instrução para aplicar.', 'error');
                    return;
                }
                const normalized = normalizeCommand(prompt);
                const node = getAutomationNode(appState.automation.selectedNodeId);
                if (!node) {
                    setAutomationPromptStatus('Nenhum node selecionado.', 'error');
                    return;
                }

                const templateMatch = normalized.match(/(?:template|workflow)\s+([a-z0-9_-]+)/);
                if (templateMatch) {
                    try {
                        const data = await fetchBackendJson(resolveWorkflowApplyApiUrl(), {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'apply_template',
                                templateId: templateMatch[1],
                                workflowName: `${appState.space.name || 'automar-video-space'}-${templateMatch[1]}`
                            })
                        }, 20000);
                        setAutomationPromptStatus(`Template aplicado: ${data.workflow.templateId}.`, 'success');
                        appendAutomationInfraLog(`Workflow ${data.workflow.workflowId.slice(0, 8)} criado via template ${data.workflow.templateId}.`, 'success');
                        addChatMessage('assistant', `Template ${data.workflow.templateId} aplicado com sucesso.`);
                    } catch (error) {
                        setAutomationPromptStatus(error.message || 'Falha ao aplicar template.', 'error');
                    }
                    return;
                }

                const changes = [];
                const delayMatch = normalized.match(/(?:wait|delay|espera|aguarde)\s+(\d{1,4})/);
                const sizeMatch = normalized.match(/(?:caption(?:s)?\s+size|size)\s+(\d{1,2})/);

                if (delayMatch) {
                    node.delayMinutes = clamp(parseInt(delayMatch[1], 10) || 0, 0, 1440);
                    changes.push(`delay ${node.delayMinutes}m`);
                }
                if (normalized.includes('uppercase')) {
                    appState.style.textCase = 'uppercase';
                    changes.push('captions uppercase');
                } else if (normalized.includes('lowercase')) {
                    appState.style.textCase = 'lowercase';
                    changes.push('captions lowercase');
                } else if (normalized.includes('normal case')) {
                    appState.style.textCase = 'normal';
                    changes.push('captions normal');
                }
                if (sizeMatch) {
                    appState.style.fontSize = clamp(parseInt(sizeMatch[1], 10) || appState.style.fontSize, 20, 72);
                    changes.push(`font ${appState.style.fontSize}px`);
                }
                if (normalized.includes('neon')) {
                    node.preset = 'neon';
                    changes.push('preset neon');
                } else if (normalized.includes('clean')) {
                    node.preset = 'clean';
                    changes.push('preset clean');
                } else if (normalized.includes('bold')) {
                    node.preset = 'bold';
                    changes.push('preset bold');
                }
                if (normalized.includes('thumb')) {
                    node.autoThumb = true;
                    changes.push('auto thumb');
                }
                if (normalized.includes('hashtag')) {
                    node.autoHashtags = true;
                    changes.push('auto hashtags');
                }

                if (!changes.length) {
                    setAutomationPromptStatus('Nenhuma regra reconhecida. Ex: "wait 20" ou "captions uppercase".', 'error');
                    return;
                }

                syncCaptionStyleControls();
                applyCaptionStyle();
                renderAutomationNodesUi();
                syncAutomationNodePanel();
                setAutomationPromptStatus(`Aplicado: ${changes.join(', ')}.`, 'success');
                appendSpaceOutput(`[Automar] ${changes.join(' · ')}`, 'success');
                addChatMessage('assistant', `Automar atualizado: ${changes.join(', ')}.`);
            }

            function updateModalBodyLock() {
                const automationOpen = videoAutomationModal && !videoAutomationModal.classList.contains('hidden');
                const timelineOpen = timelineModal && !timelineModal.classList.contains('hidden');
                document.body.classList.toggle('overflow-hidden', Boolean(automationOpen || timelineOpen));
            }

            function openVideoAutomationSpace(spaceName = '') {
                const fallback = appState.space.name || 'automar-video-space';
                const name = String(spaceName || '').trim() || fallback;
                if (!connectSpace(name, { silent: true })) return false;
                appendSpaceOutput(`Space conectado: ${name}`, 'success');

                ensureAutomationState();
                automationSpaceTitle.textContent = `${name}`;
                automationSpaceFooterName.textContent = name;
                renderAutomationNodesUi();
                syncAutomationNodePanel();
                setAutomationPromptStatus('Workspace pronto para automação de vídeos.', 'muted');
                const clip = getActiveClip() || appState.clips[0];
                if (clip && automationPatchTimestampInput) {
                    const currentTime = getPlaybackCurrentTime();
                    const ts = Number.isFinite(currentTime) ? currentTime : clip.start;
                    automationPatchTimestampInput.value = String(Number(ts.toFixed(2)));
                }
                if (automationInfraLog && !automationInfraLog.children.length) {
                    appendAutomationInfraLog('Infra pronta: ingest, patch de frame e render incremental disponíveis.', 'neutral');
                }
                loadWorkflowTemplatesFromBackend().catch(() => {});

                videoAutomationModal.classList.remove('hidden');
                videoAutomationModal.classList.add('flex');
                updateModalBodyLock();
                return true;
            }

            function closeVideoAutomationSpace() {
                videoAutomationModal.classList.add('hidden');
                videoAutomationModal.classList.remove('flex');
                setAutomationPromptStatus('');
                updateModalBodyLock();
            }

            function collectTranscriptForAutomation(maxWords = 540) {
                const words = [];
                appState.clips.forEach((clip) => {
                    if (!Array.isArray(clip.captions)) return;
                    clip.captions.forEach((caption) => {
                        const text = String(caption.text || '').trim();
                        if (!text) return;
                        words.push(...text.split(/\s+/));
                    });
                });
                return words.slice(0, maxWords).join(' ');
            }

            function resolveAutomationRuntimeSource() {
                const source = String(appState.sourceSrc || '').trim();
                if (!source) return null;
                if (source.startsWith('blob:')) return null;
                if (/^https?:\/\//i.test(source)) {
                    return {
                        sourceUrl: source,
                        youtubeUrl: appState.sourceKind === 'youtube' ? source : ''
                    };
                }
                return null;
            }

            function upsertAutomationPatchLayer(patch) {
                if (!patch || !patch.patchId) return;
                ensureAutomationState();
                const idx = appState.automation.patchLayers.findIndex((item) => item && item.patchId === patch.patchId);
                if (idx >= 0) appState.automation.patchLayers[idx] = patch;
                else appState.automation.patchLayers.unshift(patch);
                appState.automation.patchLayers = appState.automation.patchLayers.slice(0, 100);
            }

            async function runAutomationIngest() {
                if (!appState.sourceSrc) {
                    setAutomationInfraStatus('Carregue um vídeo/link antes do ingest.', 'error');
                    return;
                }

                const payload = {
                    action: 'ingest',
                    source: {
                        kind: appState.sourceKind || 'manual',
                        url: appState.sourceSrc || '',
                        label: appState.sourceLabel || ''
                    },
                    durationSec: Number(appState.duration || 0) || 60,
                    transcript: collectTranscriptForAutomation()
                };

                const data = await fetchBackendJson(resolveAutomationIngestApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, 60000);

                appState.automation.ingest = data;
                const viralCount = Number(data?.stats?.viralMoments || 0);
                appState.automation.successRate = clamp(96 + viralCount * 0.25, 90, 100);
                renderAutomationNodesUi();

                setAutomationInfraStatus(`Ingest analisado: ${data?.stats?.cuts || 0} cuts, ${viralCount} momentos virais.`, 'success');
                appendAutomationInfraLog(`Ingest ${data.ingestId} concluído (${data.durationSec}s).`, 'success');
            }

            async function loadWorkflowTemplatesFromBackend() {
                const data = await fetchBackendJson(resolveWorkflowTemplatesApiUrl(), {
                    method: 'GET',
                    cache: 'no-store'
                }, 20000);
                appState.automation.templates = Array.isArray(data.templates) ? data.templates : [];
                if (!appState.automation.templates.length) {
                    setAutomationInfraStatus('Nenhum template encontrado.', 'error');
                    return;
                }

                const names = appState.automation.templates.map((template) => template.name).slice(0, 3).join(' | ');
                setAutomationInfraStatus(`Templates carregados: ${appState.automation.templates.length}.`, 'success');
                appendAutomationInfraLog(`Templates: ${names}.`, 'neutral');
            }

            async function createAutomationFramePatch() {
                const clip = getActiveClip() || appState.clips[0];
                if (!clip) {
                    setAutomationInfraStatus('Selecione um clip para criar patch.', 'error');
                    return;
                }

                const inferredPlayhead = getPlaybackCurrentTime();
                const fallbackTs = Number.isFinite(inferredPlayhead) ? inferredPlayhead : clip.start;
                const tsInput = parseFloat(automationPatchTimestampInput.value);
                const timestampSec = Number.isFinite(tsInput) ? tsInput : fallbackTs;
                const instruction = String(automationPatchInstructionInput.value || '').trim();
                if (!instruction) {
                    setAutomationInfraStatus('Descreva a edição do frame antes de criar patch.', 'error');
                    return;
                }

                const provider = String(automationPatchProviderSelect.value || 'google_nano_banana').trim();
                const payload = {
                    action: 'frame_patch',
                    videoId: clip.id,
                    timestampSec: clamp(timestampSec, clip.start, clip.end),
                    fps: 30,
                    region: { x: 0.28, y: 0.2, width: 0.44, height: 0.56 },
                    instruction,
                    provider,
                    model: provider === 'google_nano_banana' ? 'gemini-3-pro-image-preview' : provider,
                    motionMethod: provider === 'kling' ? 'kling_3' : 'optical_flow_reprojection'
                };

                const patchResponse = await fetchBackendJson(resolveAutomationFramePatchApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, 25000);

                const patch = patchResponse.patch;
                upsertAutomationPatchLayer(patch);
                appState.automation.lastPatchResult = patchResponse;

                appendAutomationInfraLog(`Patch ${patch.patchId.slice(0, 8)} criado em ${patch.frame.timestampSec}s.`, 'success');

                const motionResponse = await fetchBackendJson(resolveAutomationMotionApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'motion_reconstruct',
                        timestampSec: patch.frame.timestampSec,
                        method: patch.propagation.method,
                        radiusSec: patch.propagation.windowSec
                    })
                }, 25000);
                appendAutomationInfraLog(`Motion job ${motionResponse.motion.motionJobId.slice(0, 8)} (${motionResponse.motion.method}).`, 'neutral');

                setAutomationInfraStatus('AI patch layer criada e motion reconstruction planejado.', 'success');
            }

            async function executeAutomationFramePatch() {
                const clip = getActiveClip() || appState.clips[0];
                if (!clip) {
                    setAutomationInfraStatus('Selecione um clip antes de executar patch.', 'error');
                    return;
                }

                const runtimeSource = resolveAutomationRuntimeSource();
                if (!runtimeSource) {
                    setAutomationInfraStatus('Execução runtime exige link público/YouTube. Para blob local, use link público ou backend com upload.', 'error');
                    return;
                }

                const inferredPlayhead = getPlaybackCurrentTime();
                const fallbackTs = Number.isFinite(inferredPlayhead) ? inferredPlayhead : clip.start;
                const tsInput = parseFloat(automationPatchTimestampInput.value);
                const timestampSec = Number.isFinite(tsInput) ? tsInput : fallbackTs;
                const instruction = String(automationPatchInstructionInput.value || '').trim();
                if (!instruction) {
                    setAutomationInfraStatus('Descreva a edição do frame para executar patch.', 'error');
                    return;
                }

                const provider = String(automationPatchProviderSelect.value || 'google_nano_banana').trim();
                const latestPatch = appState.automation.patchLayers[0] || null;
                const payload = {
                    action: 'frame_patch_execute',
                    patchId: latestPatch && latestPatch.patchId ? latestPatch.patchId : undefined,
                    videoId: clip.id,
                    timestampSec: clamp(timestampSec, clip.start, clip.end),
                    fps: 30,
                    region: latestPatch?.region || { x: 0.28, y: 0.2, width: 0.44, height: 0.56 },
                    instruction,
                    provider,
                    model: provider === 'google_nano_banana' ? 'gemini-3-pro-image-preview' : provider,
                    motionMethod: provider === 'kling' ? 'kling_3' : 'optical_flow_reprojection',
                    ...runtimeSource
                };

                const data = await fetchBackendJson(resolveAutomationFramePatchApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, 180000);

                if (data.patch) upsertAutomationPatchLayer(data.patch);
                appState.automation.lastPatchResult = data;

                if (data.motion?.motionJobId) {
                    appendAutomationInfraLog(`Motion auto ${data.motion.motionJobId.slice(0, 8)} (${data.motion.method}).`, 'neutral');
                }
                if (data.generatedImage?.provider) {
                    appendAutomationInfraLog(`Imagem de patch gerada via ${data.generatedImage.provider}.`, 'neutral');
                }

                const shortPatchId = data.patch?.patchId ? data.patch.patchId.slice(0, 8) : 'patch';
                setAutomationInfraStatus(`Patch ${shortPatchId} executado com sucesso.`, 'success');
                appendAutomationInfraLog(`Patch ${shortPatchId}: frame original/editado/diff atualizados.`, 'success');
            }

            async function planAutomationIncrementalRender() {
                const clip = getActiveClip() || appState.clips[0];
                const fallbackDuration = clip ? Math.max(2, clip.end - clip.start) : 60;
                const payload = {
                    action: 'render_incremental',
                    durationSec: Number(appState.duration || fallbackDuration) || fallbackDuration,
                    fps: 30,
                    patchLayers: appState.automation.patchLayers,
                    changedRanges: [],
                    outputProfiles: ['9:16', '1:1', '16:9']
                };

                const data = await fetchBackendJson(resolveAutomationRenderApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, 25000);

                appState.automation.renderPlan = data.renderPlan;
                const changed = Array.isArray(data.renderPlan?.changedRanges) ? data.renderPlan.changedRanges.length : 0;
                const ratio = Number(data.renderPlan?.cacheHints?.reencodeRatio || 0);
                setAutomationInfraStatus(`Render incremental pronto: ${changed} segmentos alterados (ratio ${(ratio * 100).toFixed(1)}%).`, 'success');
                appendAutomationInfraLog(`Render plan ${data.renderPlan.renderPlanId.slice(0, 8)} gerado.`, 'success');
            }

            async function executeAutomationIncrementalRender() {
                const runtimeSource = resolveAutomationRuntimeSource();
                if (!runtimeSource) {
                    setAutomationInfraStatus('Execução de render exige link público/YouTube acessível pelo backend.', 'error');
                    return;
                }

                if (!appState.automation.renderPlan) {
                    await planAutomationIncrementalRender();
                }
                if (!appState.automation.renderPlan) {
                    setAutomationInfraStatus('Não foi possível preparar render plan.', 'error');
                    return;
                }

                const clip = getActiveClip() || appState.clips[0];
                const fallbackDuration = clip ? Math.max(2, clip.end - clip.start) : 60;
                const payload = {
                    action: 'render_execute',
                    durationSec: Number(appState.duration || fallbackDuration) || fallbackDuration,
                    fps: 30,
                    renderPlan: appState.automation.renderPlan,
                    patchLayers: appState.automation.patchLayers,
                    ...runtimeSource
                };

                const data = await fetchBackendJson(resolveAutomationRenderApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, 240000);

                appState.automation.lastRenderResult = data;
                if (data.renderPlan) appState.automation.renderPlan = data.renderPlan;

                const outputUri = String(data.output?.uri || '').trim();
                const segmentCount = Number(data.stats?.totalSegments || (Array.isArray(data.segments) ? data.segments.length : 0));
                const reencoded = Number(data.stats?.reencodedSegments || 0);
                setAutomationInfraStatus(`Render executado: ${segmentCount} segmentos (${reencoded} reencode).`, 'success');

                if (outputUri) {
                    appendAutomationInfraLog(`Output: ${outputUri}`, 'success');
                } else {
                    appendAutomationInfraLog('Render concluído, mas sem URI pública de saída.', 'neutral');
                }
            }

            async function saveProviderKeyToBackend(provider, apiKey) {
                const normalizedProvider = String(provider || '').trim().toLowerCase();
                if (!normalizedProvider || !apiKey) return;
                const providerMap = {
                    openai: 'openai',
                    elevenlabs: 'elevenlabs',
                    kling: 'kling',
                    veo: 'veo',
                    google: 'google_nano_banana'
                };
                const mapped = providerMap[normalizedProvider] || normalizedProvider;
                await fetchBackendJson(resolveKeyVaultSaveApiUrl(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'save_key',
                        provider: mapped,
                        apiKey,
                        label: 'ui-default'
                    })
                }, 15000);
            }

            function applyClipVisualTransform() {
                const clip = ensureClipEditData(getActiveClip());
                const ytFrame = editorYoutubeWrap.querySelector('iframe');
                if (!clip) {
                    editorVideo.style.transform = 'none';
                    if (ytFrame) ytFrame.style.transform = 'none';
                    if (clipOverlayLayer) clipOverlayLayer.innerHTML = '';
                    return;
                }

                const scale = clamp(Number(clip.crop.zoom) || 100, 100, 180) / 100;
                const tx = clamp(Number(clip.crop.x) || 0, -40, 40);
                const ty = clamp(Number(clip.crop.y) || 0, -40, 40);
                const transform = `translate(${tx}%, ${ty}%) scale(${scale})`;

                editorVideo.style.transformOrigin = 'center center';
                editorVideo.style.transform = transform;
                if (ytFrame) {
                    ytFrame.style.transformOrigin = 'center center';
                    ytFrame.style.transform = transform;
                }

                renderClipOverlays(clip);
            }

            function renderClipOverlays(clip) {
                if (!clipOverlayLayer) return;
                const currentClip = ensureClipEditData(clip);
                if (!currentClip) {
                    clipOverlayLayer.innerHTML = '';
                    return;
                }

                const currentTime = getPlaybackCurrentTime();
                const currentAbs = Number.isFinite(currentTime) ? currentTime : currentClip.start;
                const activeFiller = Array.isArray(currentClip.fillerShots)
                    ? currentClip.fillerShots.find((shot) => currentAbs >= shot.start && currentAbs <= shot.end)
                    : null;
                const fillerMarkup = activeFiller
                    ? `<div class="absolute inset-0 z-[1]">
                        <img src="${escapeHtml(activeFiller.src)}" alt="Complement shot" class="w-full h-full object-cover opacity-95">
                        <div class="absolute inset-0 bg-gradient-to-t from-black/35 via-transparent to-black/20"></div>
                    </div>`
                    : '';

                const textOverlays = Array.isArray(currentClip.overlays) ? currentClip.overlays : [];
                const textMarkup = textOverlays.map((overlay, index) => {
                    const x = clamp(Number(overlay.x) || 50, 4, 96);
                    const y = clamp(Number(overlay.y) || 22, 5, 95);
                    const text = applyCase(String(overlay.text || `Overlay ${index + 1}`), appState.style.textCase);
                    return `
                        <div class="absolute z-[6] px-2 py-1 rounded-md border border-white/20 bg-black/55 text-white text-xs font-semibold drop-shadow-[0_3px_12px_rgba(0,0,0,0.9)]"
                             style="left:${x}%; top:${y}%; transform:translate(-50%, -50%);">
                            ${escapeHtml(text)}
                        </div>
                    `;
                }).join('');

                clipOverlayLayer.innerHTML = `${fillerMarkup}${textMarkup}`;
            }

            function setTimelineStatus(message, tone = 'muted') {
                if (!timelineStatus) return;
                timelineStatus.textContent = message || '';
                timelineStatus.classList.remove('text-red-300', 'text-accent', 'text-white/40');
                if (tone === 'error') timelineStatus.classList.add('text-red-300');
                else if (tone === 'success') timelineStatus.classList.add('text-accent');
                else timelineStatus.classList.add('text-white/40');
            }

            function getTimelineClip() {
                if (!appState.timeline.clipId) return getActiveClip();
                return appState.clips.find((clip) => clip.id === appState.timeline.clipId) || getActiveClip();
            }

            function getTimelinePlayhead() {
                const clip = getTimelineClip();
                if (!clip) return 0;
                const fallback = clip.start;
                if (!timelineScrubber) return fallback;
                const raw = Number(timelineScrubber.value) / 10;
                return Number.isFinite(raw) ? clamp(raw, clip.start, clip.end) : fallback;
            }

            function renderTimelineOverlayList(clip) {
                if (!timelineOverlayList) return;
                const currentClip = ensureClipEditData(clip);
                if (!currentClip || !currentClip.overlays.length) {
                    timelineOverlayList.innerHTML = '<div class="text-white/40 text-xs">Nenhuma sobreposição adicionada.</div>';
                    return;
                }
                timelineOverlayList.innerHTML = currentClip.overlays.map((overlay, index) => `
                    <div class="rounded-lg border border-white/10 bg-black/40 px-2 py-2 flex items-start justify-between gap-2">
                        <div>
                            <div class="text-white/80">${escapeHtml(String(overlay.text || `Overlay ${index + 1}`))}</div>
                            <div class="text-[11px] text-white/40 mt-1">x ${clamp(Number(overlay.x) || 50, 4, 96)}% · y ${clamp(Number(overlay.y) || 20, 5, 95)}%</div>
                        </div>
                        <button class="text-[11px] text-red-300 hover:text-red-200" data-remove-overlay="${escapeHtml(String(overlay.id || ''))}">remover</button>
                    </div>
                `).join('');
            }

            function syncTimelineUi() {
                if (!appState.timeline.open) return;
                const clip = ensureClipEditData(getTimelineClip());
                if (!clip) return;

                const current = getPlaybackCurrentTime();
                const playhead = Number.isFinite(current) ? clamp(current, clip.start, clip.end) : clip.start;

                timelineClipTitle.textContent = clip.title;
                timelineScrubber.min = String(Math.round(clip.start * 10));
                timelineScrubber.max = String(Math.round(clip.end * 10));
                timelineScrubber.value = String(Math.round(playhead * 10));
                timelineStartValue.textContent = formatTime(clip.start);
                timelinePlayheadValue.textContent = formatTime(playhead);
                timelineEndValue.textContent = formatTime(clip.end);
                if (timelineDurationValue) {
                    timelineDurationValue.textContent = formatTime(Math.max(0, clip.end - clip.start));
                }
                if (timelinePlayheadNeedle) {
                    const span = Math.max(clip.end - clip.start, 0.1);
                    const progress = clamp(((playhead - clip.start) / span) * 100, 0, 100);
                    timelinePlayheadNeedle.style.left = `${progress}%`;
                }
                if (timelinePlayheadTag) {
                    timelinePlayheadTag.textContent = formatTime(playhead);
                }

                timelineCropZoom.value = String(clip.crop.zoom);
                timelineCropX.value = String(clip.crop.x);
                timelineCropY.value = String(clip.crop.y);
                timelineCropZoomValue.textContent = `${clip.crop.zoom}%`;
                timelineCropXValue.textContent = `${clip.crop.x}%`;
                timelineCropYValue.textContent = `${clip.crop.y}%`;

                paintRangeInput(timelineScrubber);
                paintRangeInput(timelineCropZoom);
                paintRangeInput(timelineCropX);
                paintRangeInput(timelineCropY);
                renderTimelineOverlayList(clip);
            }

            function startTimelineSync() {
                if (timelineSyncTicker) clearInterval(timelineSyncTicker);
                timelineSyncTicker = setInterval(() => {
                    if (appState.timeline.open) syncTimelineUi();
                }, 140);
            }

            function stopTimelineSync() {
                if (timelineSyncTicker) {
                    clearInterval(timelineSyncTicker);
                    timelineSyncTicker = null;
                }
            }

            function applyTimelineCut(side) {
                const clip = ensureClipEditData(getTimelineClip());
                if (!clip) return;
                const playhead = getTimelinePlayhead();
                if (side === 'in') {
                    clip.start = roundTenth(clamp(playhead, 0, clip.end - 0.2));
                    seekPlayback(clip.start);
                } else {
                    clip.end = roundTenth(clamp(playhead, clip.start + 0.2, appState.duration));
                    seekPlayback(Math.min(playhead, clip.end));
                }
                syncClipCaptionsToTranscript(clip);
                syncClipUi(clip);
                updateCardInfo(clip);
                renderClipGrid();
                applyClipVisualTransform();
                updateVideoProgress();
                syncTimelineUi();
                setEditorStatus(`Cut aplicado (${side === 'in' ? 'IN' : 'OUT'}).`, 'success');
                setTimelineStatus(`Cut ${side === 'in' ? 'IN' : 'OUT'} aplicado.`, 'success');
            }

            function resetTimelineCut() {
                const clip = ensureClipEditData(getTimelineClip());
                if (!clip) return;
                clip.start = roundTenth(clamp(Number(clip.baseStart) || 0, 0, appState.duration - 0.2));
                clip.end = roundTenth(clamp(Number(clip.baseEnd) || clip.start + 0.2, clip.start + 0.2, appState.duration));
                syncClipCaptionsToTranscript(clip);
                syncClipUi(clip);
                updateCardInfo(clip);
                renderClipGrid();
                seekPlayback(clip.start);
                updateVideoProgress();
                syncTimelineUi();
                setEditorStatus('Cut resetado para os pontos originais do clip.', 'success');
                setTimelineStatus('Cut resetado.', 'success');
            }

            function applyTimelineCrop() {
                const clip = ensureClipEditData(getTimelineClip());
                if (!clip) return;
                clip.crop.zoom = clamp(parseInt(timelineCropZoom.value, 10) || 100, 100, 180);
                clip.crop.x = clamp(parseInt(timelineCropX.value, 10) || 0, -40, 40);
                clip.crop.y = clamp(parseInt(timelineCropY.value, 10) || 0, -40, 40);
                timelineCropZoomValue.textContent = `${clip.crop.zoom}%`;
                timelineCropXValue.textContent = `${clip.crop.x}%`;
                timelineCropYValue.textContent = `${clip.crop.y}%`;
                applyClipVisualTransform();
                paintRangeInput(timelineCropZoom);
                paintRangeInput(timelineCropX);
                paintRangeInput(timelineCropY);
            }

            function addTimelineOverlay() {
                const clip = ensureClipEditData(getTimelineClip());
                if (!clip) return;
                const text = String(timelineOverlayTextInput.value || '').trim();
                if (!text) {
                    setTimelineStatus('Digite um texto para adicionar.', 'error');
                    return;
                }
                const y = Math.min(90, 20 + (clip.overlays.length % 5) * 12);
                clip.overlays.push({
                    id: `ov-${Date.now()}-${Math.round(Math.random() * 10000)}`,
                    text,
                    x: 50,
                    y
                });
                timelineOverlayTextInput.value = '';
                renderClipOverlays(clip);
                renderTimelineOverlayList(clip);
                setTimelineStatus('Sobreposição adicionada.', 'success');
            }

            function removeTimelineOverlay(overlayId) {
                const clip = ensureClipEditData(getTimelineClip());
                if (!clip) return;
                const currentLen = clip.overlays.length;
                clip.overlays = clip.overlays.filter((item) => String(item.id) !== String(overlayId));
                if (clip.overlays.length === currentLen) return;
                renderClipOverlays(clip);
                renderTimelineOverlayList(clip);
                setTimelineStatus('Sobreposição removida.', 'success');
            }

            function copyClipStyleToClipboard() {
                const clip = ensureClipEditData(getTimelineClip() || getActiveClip());
                if (!clip) {
                    setTimelineStatus('Selecione um clip para copiar estilo.', 'error');
                    return;
                }
                appState.clipboard.clipStyle = { ...appState.style };
                appState.clipboard.crop = { ...clip.crop };
                setTimelineStatus('Estilo copiado.', 'success');
            }

            function pasteClipStyleFromClipboard() {
                const clip = ensureClipEditData(getTimelineClip() || getActiveClip());
                if (!clip) {
                    setTimelineStatus('Selecione um clip para colar estilo.', 'error');
                    return;
                }
                if (!appState.clipboard.clipStyle || !appState.clipboard.crop) {
                    setTimelineStatus('Clipboard vazio. Use Copy Style primeiro.', 'error');
                    return;
                }
                appState.style = { ...appState.style, ...appState.clipboard.clipStyle };
                clip.crop = { ...clip.crop, ...appState.clipboard.crop };
                syncCaptionStyleControls();
                applyCaptionStyle();
                applyClipVisualTransform();
                syncTimelineUi();
                setTimelineStatus('Estilo colado no clip ativo.', 'success');
            }

            async function openTimelineEditor(clipId, askConfirmation = false) {
                const clip = appState.clips.find((item) => item.id === clipId);
                if (!clip) return false;
                if (askConfirmation) {
                    const ok = window.confirm(`Abrir "${clip.title}" no editor avançado com timeline?`);
                    if (!ok) return false;
                }

                await openClipEditor(clip.id, true);
                appState.timeline.open = true;
                appState.timeline.clipId = clip.id;
                timelineModal.classList.remove('hidden');
                timelineModal.classList.add('flex');
                updateModalBodyLock();
                syncTimelineUi();
                startTimelineSync();
                setTimelineStatus('Editor avançado aberto. Use cut, crop, add e paste.', 'muted');
                return true;
            }

            function closeTimelineEditor() {
                appState.timeline.open = false;
                appState.timeline.clipId = null;
                timelineModal.classList.add('hidden');
                timelineModal.classList.remove('flex');
                stopTimelineSync();
                setTimelineStatus('');
                updateModalBodyLock();
            }

            function getCurrentClipTimeOffset() {
                const clip = getActiveClip();
                if (!clip) return 0;
                const current = getPlaybackCurrentTime();
                if (!Number.isFinite(current)) return 0;
                return clamp(current - clip.start, 0, clip.end - clip.start);
            }

            function getCaptionAtTime(clip, offsetSeconds) {
                if (!clip || !clip.captions.length) return null;
                const matches = clip.captions
                    .slice()
                    .sort((a, b) => a.time - b.time)
                    .filter((caption) => caption.time - clip.start <= offsetSeconds + 0.01);
                return matches[matches.length - 1] || clip.captions[0];
            }

            function updateCaptionPreviewText() {
                const clip = getActiveClip();
                if (!clip) {
                    captionPreviewText.textContent = 'Your caption will appear here.';
                    return;
                }
                const offset = getCurrentClipTimeOffset();
                const activeCaption = getCaptionAtTime(clip, offset);
                const rawText = activeCaption ? activeCaption.text : clip.title;
                captionPreviewText.textContent = applyCase(rawText, appState.style.textCase);
                if (activeCaption) {
                    appState.activeCaptionId = activeCaption.id;
                    const row = captionList.querySelector(`[data-caption-id="${activeCaption.id}"]`);
                    if (row && !row.classList.contains('border-accent/40')) {
                        setActiveCaptionRow(row, true);
                    }
                }
            }

            function applyCaptionStyle() {
                const style = appState.style;
                const rgb = hexToRgb(style.bgColor);
                const alpha = clamp(style.bgOpacity / 100, 0, 1);
                const familyMap = {
                    body: '"Space Grotesk", sans-serif',
                    display: '"Syne", sans-serif',
                    mono: '"JetBrains Mono", monospace'
                };

                captionPreviewText.style.fontFamily = familyMap[style.fontFamily] || familyMap.body;
                captionPreviewText.style.fontWeight = style.fontWeight;
                captionPreviewText.style.fontSize = `${style.fontSize}px`;
                captionPreviewText.style.color = style.textColor;
                captionPreviewText.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                captionPreviewText.style.padding = '0.35rem 0.55rem';
                captionPreviewText.style.borderRadius = '0.45rem';
                captionPreviewText.style.webkitTextStroke = `${clamp(Number(style.strokeSize), 0, 8)}px ${style.strokeColor}`;
                captionPreviewText.style.letterSpacing = style.textCase === 'uppercase' ? '0.04em' : '0.01em';

                captionPreviewOverlay.classList.remove('items-start', 'items-center', 'items-end', 'pt-8', 'pb-8');
                if (style.position === 'top') {
                    captionPreviewOverlay.classList.add('items-start', 'pt-8');
                } else if (style.position === 'middle') {
                    captionPreviewOverlay.classList.add('items-center');
                } else {
                    captionPreviewOverlay.classList.add('items-end', 'pb-8');
                }
                updateCaptionPreviewText();
                renderClipOverlays(getActiveClip());
            }

            function syncCaptionStyleControls() {
                const style = appState.style;
                captionFontFamilySelect.value = style.fontFamily;
                captionWeightSelect.value = style.fontWeight;
                captionTextColorInput.value = style.textColor;
                captionBgColorInput.value = style.bgColor;
                captionFontSizeInput.value = String(style.fontSize);
                captionBgOpacityInput.value = String(style.bgOpacity);
                captionPositionSelect.value = style.position;
                captionCaseSelect.value = style.textCase;
                captionStrokeColorInput.value = style.strokeColor;
                captionStrokeSizeInput.value = String(style.strokeSize);
                captionSizeValue.textContent = `${style.fontSize}px`;
                captionBgOpacityValue.textContent = `${style.bgOpacity}%`;
                paintRangeInput(captionFontSizeInput);
                paintRangeInput(captionBgOpacityInput);
            }

            function setStyleFromControls() {
                appState.style.fontFamily = captionFontFamilySelect.value;
                appState.style.fontWeight = captionWeightSelect.value;
                appState.style.textColor = captionTextColorInput.value;
                appState.style.bgColor = captionBgColorInput.value;
                appState.style.fontSize = clamp(parseInt(captionFontSizeInput.value, 10) || 38, 20, 72);
                appState.style.bgOpacity = clamp(parseInt(captionBgOpacityInput.value, 10) || 0, 0, 100);
                appState.style.position = captionPositionSelect.value;
                appState.style.textCase = captionCaseSelect.value;
                appState.style.strokeColor = captionStrokeColorInput.value;
                appState.style.strokeSize = clamp(parseInt(captionStrokeSizeInput.value, 10) || 0, 0, 8);
                captionSizeValue.textContent = `${appState.style.fontSize}px`;
                captionBgOpacityValue.textContent = `${appState.style.bgOpacity}%`;
                applyCaptionStyle();
            }

            function updateAudioUi() {
                musicVolumeInput.value = String(appState.audio.music);
                voiceVolumeInput.value = String(appState.audio.voice);
                musicVolumeLabel.textContent = `${appState.audio.music}%`;
                voiceVolumeLabel.textContent = `${appState.audio.voice}%`;
                paintRangeInput(musicVolumeInput);
                paintRangeInput(voiceVolumeInput);
            }

            function appendSpaceOutput(text, tone = 'neutral') {
                const line = document.createElement('div');
                line.className = tone === 'success' ? 'text-accent' : tone === 'error' ? 'text-red-300' : 'text-white/70';
                line.textContent = text;
                spaceOutputs.prepend(line);
            }

            function updateSpaceStatus() {
                if (appState.space.connected) {
                    spaceStatus.textContent = `Connected to ${appState.space.name}.`;
                    spaceStatus.classList.remove('text-white/50', 'text-red-300');
                    spaceStatus.classList.add('text-accent');
                } else {
                    spaceStatus.textContent = 'Space desconectado.';
                    spaceStatus.classList.remove('text-accent', 'text-red-300');
                    spaceStatus.classList.add('text-white/50');
                }
            }

            function addChatMessage(role, text) {
                const bubble = document.createElement('div');
                bubble.className = role === 'user'
                    ? 'bg-white/5 border border-white/10 rounded px-2 py-1 text-white/90'
                    : 'bg-accent/10 border border-accent/20 rounded px-2 py-1 text-white/90';
                bubble.innerHTML = `<span class="text-[10px] uppercase tracking-wide ${role === 'user' ? 'text-white/40' : 'text-accent'}">${role === 'user' ? 'You' : 'System'}</span><div class="mt-1">${escapeHtml(text)}</div>`;
                commandChatLog.appendChild(bubble);
                commandChatLog.scrollTop = commandChatLog.scrollHeight;
            }

            function normalizeCommand(command) {
                return command
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '')
                    .trim();
            }

            function paintRangeInput(input) {
                if (!input || input.type !== 'range') return;
                const min = Number(input.min) || 0;
                const max = Number(input.max) || 100;
                const current = Number(input.value) || 0;
                const val = ((current - min) / (max - min)) * 100;
                const color = input.getAttribute('data-color') || '#c8ff00';
                input.style.background = `linear-gradient(to right, ${color} ${val}%, rgba(255,255,255,0.1) ${val}%)`;
            }

            function stopYoutubeProgressTicker() {
                if (youtubeProgressTicker) {
                    clearInterval(youtubeProgressTicker);
                    youtubeProgressTicker = null;
                }
            }

            function setPreviewMode(sourceKind) {
                editorYoutubeBlockedWrap.classList.add('hidden');
                editorYoutubeBlockedWrap.classList.remove('flex');
                if (sourceKind === 'youtube') {
                    editorVideo.pause();
                    editorVideo.classList.add('hidden');
                    editorYoutubeWrap.classList.remove('hidden');
                } else if (sourceKind === 'youtube-blocked') {
                    stopYoutubeProgressTicker();
                    if (youtubePlayer && typeof youtubePlayer.pauseVideo === 'function') {
                        try {
                            youtubePlayer.pauseVideo();
                        } catch (_error) {
                            // noop
                        }
                    }
                    editorVideo.pause();
                    editorVideo.classList.add('hidden');
                    editorYoutubeWrap.classList.add('hidden');
                    editorYoutubeBlockedWrap.classList.remove('hidden');
                    editorYoutubeBlockedWrap.classList.add('flex');
                } else {
                    stopYoutubeProgressTicker();
                    if (youtubePlayer && typeof youtubePlayer.pauseVideo === 'function') {
                        try {
                            youtubePlayer.pauseVideo();
                        } catch (_error) {
                            // noop
                        }
                    }
                    editorYoutubeWrap.classList.add('hidden');
                    editorVideo.classList.remove('hidden');
                }
            }

            function sanitizeYoutubeVideoId(rawId) {
                const cleaned = String(rawId || '').split('?')[0].split('&')[0].trim();
                if (/^[a-zA-Z0-9_-]{11}$/.test(cleaned)) return cleaned;
                return null;
            }

            function extractYoutubeVideoId(parsedUrl) {
                const host = parsedUrl.hostname.toLowerCase().replace(/^www\./, '');

                if (host === 'youtu.be') {
                    const shortPath = parsedUrl.pathname.split('/').filter(Boolean)[0];
                    return sanitizeYoutubeVideoId(shortPath);
                }

                if (host.endsWith('youtube.com') || host.endsWith('youtube-nocookie.com')) {
                    const fromQuery = sanitizeYoutubeVideoId(parsedUrl.searchParams.get('v'));
                    if (fromQuery) return fromQuery;

                    const parts = parsedUrl.pathname.split('/').filter(Boolean);
                    if (!parts.length) return null;
                    if (['shorts', 'embed', 'live', 'v'].includes(parts[0])) {
                        return sanitizeYoutubeVideoId(parts[1]);
                    }
                }
                return null;
            }

            function parseSourceFromUrl(rawUrl) {
                const trimmed = rawUrl.trim();
                const withProtocol = /^https?:\/\//i.test(trimmed) ? trimmed : `https://${trimmed}`;
                let parsed;
                try {
                    parsed = new URL(withProtocol);
                } catch (_error) {
                    throw new Error('Please paste a valid URL.');
                }

                const host = parsed.hostname.toLowerCase();
                const youtubeVideoId = extractYoutubeVideoId(parsed);
                if (youtubeVideoId) {
                    return {
                        sourceKind: 'youtube',
                        src: parsed.toString(),
                        label: `youtube.com/watch?v=${youtubeVideoId}`,
                        youtubeVideoId
                    };
                }
                if (host.includes('youtube.com') || host === 'youtu.be') {
                    throw new Error('Não consegui identificar o ID do vídeo no link do YouTube. Confira a URL.');
                }

                if (/(tiktok\.com|instagram\.com)/.test(host)) {
                    throw new Error('Suporte social direto está habilitado apenas para YouTube nesta versão. Para outros links, envie o arquivo de vídeo.');
                }

                return {
                    sourceKind: 'link',
                    src: parsed.toString(),
                    label: sourceLabelFromUrl(parsed.toString()),
                    youtubeVideoId: ''
                };
            }

            function sourceLabelFromUrl(url) {
                try {
                    const parsed = new URL(url);
                    const host = parsed.hostname.replace(/^www\./, '');
                    const leaf = parsed.pathname.split('/').filter(Boolean).pop();
                    return leaf ? `${host}/${leaf}` : host;
                } catch (_error) {
                    return 'External video URL';
                }
            }

            function youtubeErrorMessage(code) {
                if (code === 2) return 'Link do YouTube inválido (ID do vídeo incorreto).';
                if (code === 5) return 'Erro do player HTML5 do YouTube para este vídeo.';
                if (code === 100) return 'Vídeo do YouTube indisponível, privado ou removido.';
                if (code === 101 || code === 150) return 'Este vídeo do YouTube não permite reprodução incorporada.';
                return 'O YouTube não conseguiu carregar esse vídeo.';
            }

            function ensureYoutubeApi() {
                if (window.YT && window.YT.Player) {
                    return Promise.resolve(window.YT);
                }
                if (youtubeApiPromise) return youtubeApiPromise;

                youtubeApiPromise = new Promise((resolve, reject) => {
                    const existingScript = document.querySelector('script[data-youtube-iframe-api="1"]');
                    const previousReady = window.onYouTubeIframeAPIReady;
                    const timeout = setTimeout(() => {
                        reject(new Error('Tempo limite ao carregar API do YouTube.'));
                    }, 15000);

                    window.onYouTubeIframeAPIReady = () => {
                        if (typeof previousReady === 'function') previousReady();
                        clearTimeout(timeout);
                        resolve(window.YT);
                    };

                    if (!existingScript) {
                        const script = document.createElement('script');
                        script.src = 'https://www.youtube.com/iframe_api';
                        script.async = true;
                        script.dataset.youtubeIframeApi = '1';
                        script.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error('Falha ao carregar player do YouTube.'));
                        };
                        document.head.appendChild(script);
                    }
                });
                youtubeApiPromise = youtubeApiPromise.catch((error) => {
                    youtubeApiPromise = null;
                    throw error;
                });
                return youtubeApiPromise;
            }

            function waitForYoutubeDuration(player) {
                return new Promise((resolve, reject) => {
                    const startedAt = Date.now();
                    let nudged = false;
                    const interval = setInterval(() => {
                        if (appState.youtubeLastErrorCode !== null) {
                            clearInterval(interval);
                            reject(new Error(youtubeErrorMessage(appState.youtubeLastErrorCode)));
                            return;
                        }

                        const duration = Number(player && typeof player.getDuration === 'function' ? player.getDuration() : 0);
                        if (Number.isFinite(duration) && duration > 0) {
                            clearInterval(interval);
                            resolve(duration);
                            return;
                        }

                        if (!nudged && Date.now() - startedAt > 4000 && youtubeCurrentVideoId) {
                            nudged = true;
                            try {
                                player.cueVideoById({ videoId: youtubeCurrentVideoId, startSeconds: 0 });
                            } catch (_error) {
                                // noop
                            }
                        }

                        if (Date.now() - startedAt > 15000) {
                            clearInterval(interval);
                            reject(new Error('Não foi possível ler a duração do vídeo no YouTube.'));
                        }
                    }, 200);
                });
            }

            function onYoutubeStateChange(event) {
                const playerStates = window.YT && window.YT.PlayerState;
                if (!playerStates) return;

                if (event.data === playerStates.PLAYING) {
                    playIcon.setAttribute('icon', 'solar:pause-bold');
                    if (!youtubeProgressTicker) {
                        youtubeProgressTicker = setInterval(() => {
                            if (appState.sourceKind === 'youtube') updateVideoProgress();
                        }, 120);
                    }
                } else {
                    playIcon.setAttribute('icon', 'solar:play-bold');
                    if (event.data === playerStates.PAUSED || event.data === playerStates.ENDED || event.data === playerStates.CUED) {
                        stopYoutubeProgressTicker();
                    }
                }
            }

            async function ensureYoutubePlayerInstance(initialVideoId = '') {
                if (youtubePlayer) return youtubePlayer;
                if (!youtubePlayerInitPromise) {
                    const YT = await ensureYoutubeApi();
                    youtubePlayerInitPromise = new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Não foi possível iniciar o player do YouTube.'));
                        }, 15000);

                        const playerOrigin = /^https?:$/.test(window.location.protocol) ? window.location.origin : undefined;

                        youtubePlayer = new YT.Player('editorYoutubePlayer', {
                            videoId: initialVideoId || undefined,
                            playerVars: {
                                controls: 0,
                                rel: 0,
                                modestbranding: 1,
                                playsinline: 1,
                                ...(playerOrigin ? { origin: playerOrigin } : {})
                            },
                            events: {
                                onReady: () => {
                                    clearTimeout(timeout);
                                    youtubeCurrentVideoId = initialVideoId || '';
                                    resolve(youtubePlayer);
                                },
                                onError: (event) => {
                                    appState.youtubeLastErrorCode = event && Number.isFinite(event.data) ? event.data : -1;
                                    clearTimeout(timeout);
                                    reject(new Error(youtubeErrorMessage(appState.youtubeLastErrorCode)));
                                },
                                onStateChange: onYoutubeStateChange
                            }
                        });
                    });
                    youtubePlayerInitPromise = youtubePlayerInitPromise.catch((error) => {
                        youtubePlayerInitPromise = null;
                        youtubePlayer = null;
                        throw error;
                    });
                }
                return youtubePlayerInitPromise;
            }

            async function ensureYoutubeVideoLoaded(videoId, startAt = 0, autoplay = false) {
                const player = await ensureYoutubePlayerInstance(videoId);
                appState.youtubeLastErrorCode = null;
                const shouldReload = youtubeCurrentVideoId !== videoId;
                const startSeconds = Math.max(0, startAt);

                if (shouldReload) {
                    player.cueVideoById({ videoId, startSeconds });
                    youtubeCurrentVideoId = videoId;
                } else {
                    player.cueVideoById({ videoId, startSeconds });
                }

                const duration = await waitForYoutubeDuration(player);
                player.seekTo(startSeconds, true);
                if (autoplay) {
                    player.playVideo();
                } else {
                    player.pauseVideo();
                }
                return { player, duration };
            }

            async function probeYoutubeDuration(videoId) {
                const { player, duration } = await ensureYoutubeVideoLoaded(videoId, 0, false);
                try {
                    player.pauseVideo();
                } catch (_error) {
                    // noop
                }
                return duration;
            }

            function parseDurationStringToSeconds(rawValue) {
                const value = String(rawValue || '').trim();
                if (!value) return Number.NaN;
                const direct = Number(value);
                if (Number.isFinite(direct) && direct > 0) return direct;
                if (!/^\d{1,3}:\d{1,2}(:\d{1,2})?$/.test(value)) return Number.NaN;
                const parts = value.split(':').map((part) => parseInt(part, 10));
                if (parts.some((part) => !Number.isFinite(part) || part < 0)) return Number.NaN;
                if (parts.length === 2) return parts[0] * 60 + parts[1];
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }

            async function probeYoutubeDurationFromBackend(youtubeUrl) {
                let response;
                try {
                    response = await fetchWithTimeout(resolveYoutubeMetadataApiUrl(), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ youtubeUrl })
                    }, 90000);
                } catch (_error) {
                    throw new Error('Backend indisponível para buscar metadados do YouTube.');
                }

                const payload = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(payload.error || 'Falha ao ler metadados do YouTube via backend.');
                }

                const duration = parseDurationStringToSeconds(payload.duration);
                if (!Number.isFinite(duration) || duration <= 0) {
                    throw new Error('Backend não retornou duração válida do vídeo.');
                }

                return {
                    duration,
                    title: String(payload.title || '').trim(),
                    videoId: String(payload.videoId || '').trim()
                };
            }

            function decodeHeaderValue(value) {
                const raw = String(value || '').trim();
                if (!raw) return '';
                try {
                    return decodeURIComponent(raw);
                } catch (_error) {
                    return raw;
                }
            }

            async function ingestYoutubeSource(youtubeUrl, fallbackLabel = '', fallbackVideoId = '') {
                const youtubeCookies = getResolvedYoutubeCookies();
                const youtubeCookiesBase64 = encodeBase64Utf8(youtubeCookies);

                let response;
                try {
                    response = await fetchWithTimeout(resolveYoutubeIngestApiUrl(), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            youtubeUrl,
                            ...(youtubeCookiesBase64 ? { youtubeCookiesBase64 } : {})
                        })
                    }, 360000);
                } catch (_error) {
                    throw new Error('Backend indisponível para ingestão de vídeo do YouTube.');
                }

                if (!response.ok) {
                    const maybeJson = await response.json().catch(() => null);
                    const errorMessage = maybeJson && typeof maybeJson.error === 'string'
                        ? maybeJson.error
                        : `Falha ao ingerir YouTube (HTTP ${response.status}).`;
                    throw new Error(errorMessage);
                }

                const mediaBlob = await response.blob();
                if (!mediaBlob || !mediaBlob.size) {
                    throw new Error('Ingestão retornou mídia vazia.');
                }

                const sourceObjectUrl = URL.createObjectURL(mediaBlob);
                appState.objectUrl = sourceObjectUrl;

                const videoId = decodeHeaderValue(response.headers.get('x-source-video-id')) || fallbackVideoId || '';
                const title = decodeHeaderValue(response.headers.get('x-source-title')) || '';
                const labelFromHeader = decodeHeaderValue(response.headers.get('x-source-label')) || '';
                const durationHeaderRaw = response.headers.get('x-source-duration');
                const durationHeader = Number(durationHeaderRaw);
                const duration = Number.isFinite(durationHeader) && durationHeader > 0
                    ? durationHeader
                    : await probeDuration(sourceObjectUrl);

                const label = labelFromHeader
                    || (title ? `Ingested • ${title}` : fallbackLabel || (videoId ? `youtube.com/watch?v=${videoId}` : 'YouTube ingest'));

                return {
                    src: sourceObjectUrl,
                    label,
                    sourceKind: 'ingested',
                    duration,
                    youtubeVideoId: videoId,
                    youtubePlaybackBlocked: false,
                    youtubePlaybackBlockReason: '',
                    ingestedMediaBlob: mediaBlob
                };
            }

            function probeDuration(src) {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        cleanup();
                        reject(new Error('Timed out reading video metadata. Use a direct public video URL or upload a file.'));
                    }, 15000);

                    const cleanup = () => {
                        clearTimeout(timeout);
                        metadataProbe.onloadedmetadata = null;
                        metadataProbe.onerror = null;
                    };

                    metadataProbe.onloadedmetadata = () => {
                        cleanup();
                        if (!Number.isFinite(metadataProbe.duration) || metadataProbe.duration <= 0) {
                            reject(new Error('Could not read clip timing from this source.'));
                            return;
                        }
                        resolve(metadataProbe.duration);
                    };

                    metadataProbe.onerror = () => {
                        cleanup();
                        reject(new Error('Video failed to load. Make sure the URL points to a playable file.'));
                    };

                    metadataProbe.src = src;
                    metadataProbe.load();
                });
            }

            async function loadSource(urlValue, file) {
                cleanupObjectUrl();

                let src;
                let label;
                let sourceKind;
                let youtubeVideoId = '';
                let youtubePlaybackBlocked = false;
                let youtubePlaybackBlockReason = '';
                let ingestedMediaBlob = null;
                let duration;
                if (file) {
                    src = URL.createObjectURL(file);
                    appState.objectUrl = src;
                    label = file.name;
                    sourceKind = 'upload';
                    appState.ingestedMediaBlob = null;
                    duration = await probeDuration(src);
                } else {
                    const parsedSource = parseSourceFromUrl(urlValue);
                    src = parsedSource.src;
                    label = parsedSource.label;
                    sourceKind = parsedSource.sourceKind;
                    youtubeVideoId = parsedSource.youtubeVideoId;
                    if (sourceKind === 'youtube') {
                        const ingested = await ingestYoutubeSource(src, label, youtubeVideoId);
                        src = ingested.src;
                        label = ingested.label;
                        sourceKind = ingested.sourceKind;
                        duration = ingested.duration;
                        youtubeVideoId = ingested.youtubeVideoId || youtubeVideoId;
                        youtubePlaybackBlocked = Boolean(ingested.youtubePlaybackBlocked);
                        youtubePlaybackBlockReason = String(ingested.youtubePlaybackBlockReason || '');
                        ingestedMediaBlob = ingested.ingestedMediaBlob || null;
                    } else {
                        ingestedMediaBlob = null;
                        duration = await probeDuration(src);
                    }
                }

                return {
                    src,
                    label,
                    sourceKind,
                    duration,
                    youtubeVideoId,
                    youtubePlaybackBlocked,
                    youtubePlaybackBlockReason,
                    ingestedMediaBlob
                };
            }

            function buildCaptions(clip, theme) {
                const span = clip.end - clip.start;
                const step = Math.max(1, span / 3);
                return [
                    {
                        id: `${clip.id}-caption-1`,
                        time: roundTenth(clip.start),
                        text: `Open with a bold statement about ${theme.title.toLowerCase()}.`
                    },
                    {
                        id: `${clip.id}-caption-2`,
                        time: roundTenth(clip.start + step),
                        text: `Drop the key point here so the viewer stays until the payoff.`
                    },
                    {
                        id: `${clip.id}-caption-3`,
                        time: roundTenth(Math.min(clip.end - 0.3, clip.start + step * 2)),
                        text: `End with a clear takeaway and invitation to comment.`
                    }
                ];
            }

            function buildClips(duration) {
                if (duration <= 0) return [];

                if (duration <= 8) {
                    const base = {
                        id: 'clip-1',
                        title: 'Short Clip',
                        category: 'highscore',
                        hook: 'Hook: Quick Win',
                        score: 92,
                        start: 0,
                        end: roundTenth(duration),
                        theme: clipThemes[0].title
                    };
                    return [{ ...base, captions: buildCaptions(base, clipThemes[0]) }]
                        .map((clip) => ensureClipEditData(enrichClipMetadata(clip, clipThemes[0].title)));
                }

                const clipCount = Math.min(9, Math.max(4, Math.round(duration / 28)));
                const baseLength = clamp(duration / (clipCount + 0.8), 9, 42);
                const usableSpan = Math.max(0, duration - baseLength - 0.2);
                const baseStep = clipCount > 1 ? usableSpan / (clipCount - 1) : 0;
                const lengthPattern = [0.72, 0.58, 0.86, 0.67, 0.93, 0.62, 0.78, 0.69, 0.88];
                const offsetPattern = [0, 0.08, -0.04, 0.12, -0.07, 0.16, -0.1, 0.2, -0.14];

                return Array.from({ length: clipCount }, (_, index) => {
                    const steppedStart = (baseStep * index) + (baseStep * offsetPattern[index % offsetPattern.length]);
                    const start = roundTenth(clamp(steppedStart, 0, Math.max(0, duration - 6)));
                    const patternedLength = baseLength * lengthPattern[index % lengthPattern.length];
                    const clipLength = clamp(patternedLength + (index % 2 ? 1.6 : -0.8), 7, 48);
                    const end = roundTenth(clamp(start + clipLength, start + 6, duration));
                    const theme = clipThemes[index % clipThemes.length];
                    const clip = {
                        id: `clip-${index + 1}`,
                        title: `${theme.title} #${index + 1}`,
                        category: index < Math.ceil(clipCount * 0.6) ? 'highscore' : 'drafts',
                        hook: theme.hook,
                        score: Math.max(70, 97 - index * 5),
                        start,
                        end,
                        theme: theme.title
                    };
                    return { ...clip, captions: buildCaptions(clip, theme) };
                }).map((clip) => ensureClipEditData(enrichClipMetadata(clip, clip.theme)));
            }

            function getActiveClip() {
                return ensureClipEditData(appState.clips.find((clip) => clip.id === appState.activeClipId) || null);
            }

            function updateFilterCounts() {
                const counts = {
                    all: appState.clips.length,
                    highscore: appState.clips.filter((clip) => clip.category === 'highscore').length,
                    drafts: appState.clips.filter((clip) => clip.category === 'drafts').length
                };

                filterBtns.forEach((btn) => {
                    const key = btn.dataset.filter;
                    if (key === 'all') btn.textContent = `All (${counts.all})`;
                    if (key === 'highscore') btn.textContent = `High Score (${counts.highscore})`;
                    if (key === 'drafts') btn.textContent = `Drafts (${counts.drafts})`;
                });
            }

            function clipCardMarkup(clip) {
                const activeClass = clip.id === appState.activeClipId
                    ? 'border-accent/40 shadow-[0_0_25px_rgba(200,255,0,0.08)]'
                    : 'border-white/10';
                const themeLabel = String(clip.theme || 'General');
                const subjectLabel = String(clip.subject || 'Geral');
                const themeId = String(clip.themeId || toFilterId(themeLabel, 'general'));
                const subjectId = String(clip.subjectId || toFilterId(subjectLabel, 'geral'));

                return `
                    <div class="clip-card group relative bg-white/[0.02] ${activeClass} rounded-xl overflow-hidden backdrop-blur-sm transition-all duration-400 hover:-translate-y-1 hover:border-accent/30 hover:shadow-[0_10px_40px_rgba(0,0,0,0.6)]" data-category="${clip.category}" data-theme="${escapeHtml(themeId)}" data-subject="${escapeHtml(subjectId)}" data-clip-id="${clip.id}" title="Double click to open advanced timeline editor">
                        <div class="relative aspect-[9/16] bg-black/80 overflow-hidden cursor-pointer play-trigger">
                            <div class="absolute inset-0 bg-[radial-gradient(circle_at_20%_20%,rgba(200,255,0,0.22),transparent_38%),radial-gradient(circle_at_80%_80%,rgba(255,255,255,0.16),transparent_45%),linear-gradient(to_bottom_right,#111,#000)]"></div>
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-14 h-14 bg-black/40 backdrop-blur-md rounded-full flex items-center justify-center border border-white/20 hover:scale-110 transition-transform">
                                    <iconify-icon icon="solar:play-bold" class="text-white text-2xl translate-x-[2px]" width="24" height="24"></iconify-icon>
                                </div>
                            </div>
                            <div class="absolute top-3 left-3 ${clip.category === 'highscore' ? 'bg-accent text-bg' : 'bg-white/20 backdrop-blur-md text-white border border-white/10'} text-xs font-semibold tracking-wide uppercase px-2 py-1 rounded flex items-center gap-1">
                                ${clip.category === 'highscore' ? `<iconify-icon icon="solar:flame-bold" width="12" height="12"></iconify-icon> Score ${clip.score}` : 'Draft'}
                            </div>
                            <div class="absolute bottom-3 right-3 bg-black/80 backdrop-blur-sm text-white/90 text-xs px-1.5 py-0.5 rounded border border-white/10 font-mono clip-length">${formatTime(clip.end - clip.start)}</div>
                        </div>
                        <div class="p-4 border-t border-white/5">
                            <h3 class="font-display font-medium text-sm text-white/90 line-clamp-2 leading-snug mb-4 group-hover:text-accent transition-colors clip-title">${clip.title}</h3>
                            <div class="flex items-center justify-between">
                                <span class="text-xs text-white/40 uppercase tracking-wider">${clip.hook}</span>
                                <div class="flex gap-2">
                                    <button class="edit-btn w-8 h-8 flex items-center justify-center rounded-lg bg-white/5 hover:bg-white/15 border border-white/10 text-white/70 hover:text-white transition-colors" title="Edit">
                                        <iconify-icon icon="solar:pen-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                    <button class="export-btn w-8 h-8 flex items-center justify-center rounded-lg bg-accent/10 hover:bg-accent/20 border border-accent/20 text-accent transition-colors" title="Export">
                                        <iconify-icon icon="solar:download-minimalistic-linear" width="16" height="16"></iconify-icon>
                                    </button>
                                </div>
                            </div>
                            <p class="text-[10px] text-white/35 mt-2 uppercase tracking-wider">${escapeHtml(themeLabel)} · ${escapeHtml(subjectLabel)}</p>
                            <p class="text-[10px] text-white/25 mt-1">Double click: timeline editor</p>
                        </div>
                    </div>
                `;
            }

            function renderClipGrid() {
                clipGrid.innerHTML = appState.clips.map((clip) => clipCardMarkup(clip)).join('');
                if (processingCard) {
                    processingCard.classList.add('hidden');
                    clipGrid.appendChild(processingCard);
                }
                updateThemeSubjectFilterOptions();
                applyFilter(appState.activeFilter);
            }

            function applyFilter(filter) {
                appState.activeFilter = filter;
                filterBtns.forEach((btn) => {
                    const isActive = btn.dataset.filter === filter;
                    btn.classList.toggle('bg-white/10', isActive);
                    btn.classList.toggle('text-white', isActive);
                    btn.classList.toggle('shadow-sm', isActive);
                    btn.classList.toggle('hover:bg-white/5', !isActive);
                    btn.classList.toggle('text-white/50', !isActive);
                });

                clipGrid.querySelectorAll('.clip-card').forEach((card) => {
                    const matchesCategory = filter === 'all' || card.dataset.category === filter;
                    const matchesTheme = appState.activeThemeFilter === 'all' || card.dataset.theme === appState.activeThemeFilter;
                    const matchesSubject = appState.activeSubjectFilter === 'all' || card.dataset.subject === appState.activeSubjectFilter;
                    card.style.display = matchesCategory && matchesTheme && matchesSubject ? 'block' : 'none';
                });
            }

            function setActiveCaptionRow(activeRow, skipPreviewUpdate = false) {
                captionList.querySelectorAll('.caption-row').forEach((row) => {
                    const timeNode = row.querySelector('.caption-time');
                    const accentNode = row.querySelector('.caption-accent');
                    row.classList.remove('border-accent/40', 'bg-accent/[0.05]', 'shadow-[0_0_15px_rgba(200,255,0,0.05)]');
                    row.classList.add('border-white/5', 'bg-white/[0.01]');
                    if (timeNode) {
                        timeNode.classList.remove('text-accent');
                        timeNode.classList.add('text-white/40');
                    }
                    if (accentNode) accentNode.classList.add('hidden');
                });

                if (!activeRow) {
                    appState.activeCaptionId = null;
                    return;
                }
                const activeTimeNode = activeRow.querySelector('.caption-time');
                const activeAccent = activeRow.querySelector('.caption-accent');
                activeRow.classList.remove('border-white/5', 'bg-white/[0.01]');
                activeRow.classList.add('border-accent/40', 'bg-accent/[0.05]', 'shadow-[0_0_15px_rgba(200,255,0,0.05)]');
                if (activeTimeNode) {
                    activeTimeNode.classList.remove('text-white/40');
                    activeTimeNode.classList.add('text-accent');
                }
                if (activeAccent) activeAccent.classList.remove('hidden');
                appState.activeCaptionId = activeRow.dataset.captionId || null;
                if (!skipPreviewUpdate) updateCaptionPreviewText();
            }

            function renderCaptions(clip) {
                captionList.innerHTML = clip.captions.map((caption) => `
                    <div class="caption-row flex gap-3 p-3 rounded-xl border border-white/5 bg-white/[0.01] hover:bg-white/[0.03] transition-colors group relative cursor-text" data-caption-id="${caption.id}" data-caption-time="${caption.time}">
                        <div class="caption-accent hidden absolute left-0 top-0 bottom-0 w-[3px] bg-accent shadow-[0_0_8px_rgba(200,255,0,0.8)]"></div>
                        <div class="caption-time text-xs text-white/40 font-mono mt-2 w-10 text-right">${formatTime(caption.time)}</div>
                        <div class="flex-grow">
                            <textarea class="w-full bg-transparent text-white text-sm resize-none outline-none font-medium leading-relaxed" rows="2" data-caption-id="${caption.id}">${escapeHtml(caption.text)}</textarea>
                        </div>
                    </div>
                `).join('');

                const firstRow = captionList.querySelector('.caption-row');
                if (firstRow) setActiveCaptionRow(firstRow);
                else appState.activeCaptionId = null;
                updateCaptionPreviewText();
            }

            function syncClipUi(clip) {
                clipStartInput.value = clip.start.toFixed(1);
                clipEndInput.value = clip.end.toFixed(1);
                clipDurationLabel.textContent = `Duration: ${formatTime(clip.end - clip.start)}`;
                timeLabel.textContent = `${formatTime(0)} / ${formatTime(clip.end - clip.start)}`;
                updateCaptionPreviewText();
            }

            function isYoutubeSource() {
                return appState.sourceKind === 'youtube';
            }

            function isYoutubePlaybackBlocked() {
                return isYoutubeSource() && appState.youtubePlaybackBlocked;
            }

            function getPlaybackCurrentTime() {
                if (isYoutubeSource()) {
                    if (isYoutubePlaybackBlocked()) return Number.NaN;
                    if (!youtubePlayer || typeof youtubePlayer.getCurrentTime !== 'function') return Number.NaN;
                    const current = Number(youtubePlayer.getCurrentTime());
                    return Number.isFinite(current) ? current : Number.NaN;
                }
                const current = Number(editorVideo.currentTime);
                return Number.isFinite(current) ? current : Number.NaN;
            }

            function getPlaybackStateIsPlaying() {
                if (isYoutubeSource()) {
                    if (isYoutubePlaybackBlocked()) return false;
                    if (!youtubePlayer || !window.YT || !window.YT.PlayerState) return false;
                    return youtubePlayer.getPlayerState() === window.YT.PlayerState.PLAYING;
                }
                return !editorVideo.paused;
            }

            function seekPlayback(seconds) {
                const target = Math.max(0, seconds);
                if (isYoutubeSource()) {
                    if (isYoutubePlaybackBlocked()) return;
                    if (youtubePlayer && typeof youtubePlayer.seekTo === 'function') {
                        youtubePlayer.seekTo(target, true);
                    }
                } else {
                    editorVideo.currentTime = target;
                }
            }

            async function playPlayback() {
                if (isYoutubeSource()) {
                    if (isYoutubePlaybackBlocked()) {
                        throw new Error('Preview deste YouTube está bloqueado para incorporação.');
                    }
                    if (!youtubePlayer || typeof youtubePlayer.playVideo !== 'function') {
                        throw new Error('YouTube player is not ready yet.');
                    }
                    youtubePlayer.playVideo();
                    return;
                }
                await editorVideo.play();
            }

            function pausePlayback() {
                if (isYoutubeSource()) {
                    if (youtubePlayer && typeof youtubePlayer.pauseVideo === 'function') {
                        youtubePlayer.pauseVideo();
                    }
                    stopYoutubeProgressTicker();
                    return;
                }
                editorVideo.pause();
            }

            function updateVideoProgress() {
                const clip = getActiveClip();
                const currentTime = getPlaybackCurrentTime();
                if (!clip || !Number.isFinite(currentTime)) return;

                const epsilon = isYoutubeSource() ? 0.08 : 0;
                let clampedCurrent = currentTime;
                if (clampedCurrent < clip.start - epsilon) {
                    seekPlayback(clip.start);
                    clampedCurrent = clip.start;
                }
                if (clampedCurrent >= clip.end - epsilon) {
                    if (getPlaybackStateIsPlaying()) {
                        seekPlayback(clip.start);
                        playPlayback().catch(() => {});
                    } else {
                        seekPlayback(clip.start);
                    }
                    clampedCurrent = clip.start;
                }

                const clipSpan = Math.max(0.1, clip.end - clip.start);
                const offset = Math.max(0, Math.min(clipSpan, clampedCurrent - clip.start));
                const pct = (offset / clipSpan) * 100;
                progressBar.style.width = `${pct}%`;
                timeLabel.textContent = `${formatTime(offset)} / ${formatTime(clipSpan)}`;
                renderClipOverlays(clip);
                updateCaptionPreviewText();
            }

            function updateCardInfo(clip) {
                const card = clipGrid.querySelector(`[data-clip-id="${clip.id}"]`);
                if (!card) return;
                const titleNode = card.querySelector('.clip-title');
                const lengthNode = card.querySelector('.clip-length');
                if (titleNode) titleNode.textContent = clip.title;
                if (lengthNode) lengthNode.textContent = formatTime(clip.end - clip.start);
            }

            async function openClipEditor(clipId, shouldScroll = true) {
                const clip = ensureClipEditData(appState.clips.find((item) => item.id === clipId));
                if (!clip) return;

                appState.activeClipId = clipId;
                if (appState.timeline.open) appState.timeline.clipId = clipId;
                editorTitle.textContent = clip.title;
                syncClipUi(clip);
                renderCaptions(clip);
                renderClipGrid();
                const blockedYoutubePreview = isYoutubePlaybackBlocked();
                setPreviewMode(blockedYoutubePreview ? 'youtube-blocked' : appState.sourceKind);
                applyCaptionStyle();
                syncCaptionStyleControls();
                updateAudioUi();

                try {
                    if (isYoutubeSource()) {
                        if (blockedYoutubePreview) {
                            const reason = appState.youtubePlaybackBlockReason || 'Este vídeo não permite reprodução incorporada.';
                            editorYoutubeBlockedText.textContent = `Preview indisponível: ${reason} Você ainda pode editar cortes, legendas, thumbnails e gerar pack.`;
                            setEditorStatus('Preview do YouTube indisponível. Edição de cortes e legendas permanece ativa.', 'muted');
                            progressBar.style.width = '0%';
                            timeLabel.textContent = `${formatTime(0)} / ${formatTime(clip.end - clip.start)}`;
                        } else {
                            await ensureYoutubeVideoLoaded(appState.youtubeVideoId, clip.start, false);
                            updateVideoProgress();
                        }
                    } else {
                        if (editorVideo.src !== appState.sourceSrc) {
                            editorVideo.src = appState.sourceSrc;
                        }
                        if (editorVideo.readyState >= 1) {
                            seekPlayback(clip.start);
                            updateVideoProgress();
                        } else {
                            editorVideo.addEventListener('loadedmetadata', () => {
                                seekPlayback(clip.start);
                                updateVideoProgress();
                            }, { once: true });
                            editorVideo.load();
                        }
                    }
                } catch (error) {
                    if (isYoutubeSource()) {
                        appState.youtubePlaybackBlocked = true;
                        appState.youtubePlaybackBlockReason = error.message || 'Falha no preview do YouTube.';
                        setPreviewMode('youtube-blocked');
                        editorYoutubeBlockedText.textContent = `Preview indisponível: ${appState.youtubePlaybackBlockReason} Você ainda pode editar cortes, legendas e gerar pack.`;
                        setEditorStatus('Preview do YouTube falhou. Fluxo segue ativo sem player incorporado.', 'muted');
                        updateWorkflowGuide();
                    } else {
                        setEditorStatus(error.message || 'Failed to load video into editor.', 'error');
                    }
                }

                editorSection.classList.remove('hidden');
                setTimeout(() => editorSection.classList.remove('opacity-0'), 50);
                if (shouldScroll) editorSection.scrollIntoView({ behavior: 'smooth' });
                applyClipVisualTransform();
                renderComplementImageList();
                if (appState.timeline.open) syncTimelineUi();
                updateWorkflowGuide();
            }

            function commitTimingInput(changedField) {
                const clip = getActiveClip();
                if (!clip) return;

                let start = parseFloat(clipStartInput.value);
                let end = parseFloat(clipEndInput.value);
                if (!Number.isFinite(start)) start = clip.start;
                if (!Number.isFinite(end)) end = clip.end;

                start = Math.max(0, Math.min(start, appState.duration - 0.2));
                end = Math.max(0.2, Math.min(end, appState.duration));

                if (changedField === 'start' && start >= end - 0.2) end = Math.min(appState.duration, start + 0.2);
                if (changedField === 'end' && end <= start + 0.2) start = Math.max(0, end - 0.2);

                clip.start = roundTenth(start);
                clip.end = roundTenth(end);
                syncClipCaptionsToTranscript(clip);
                syncClipUi(clip);
                if (appState.captionsSource === 'transcribed' && appState.transcriptWords.length) {
                    renderClipGrid();
                } else {
                    updateCardInfo(clip);
                }
                setEditorStatus('Clip timing updated.', 'success');

                const currentTime = getPlaybackCurrentTime();
                if (!Number.isFinite(currentTime) || currentTime < clip.start || currentTime > clip.end) {
                    seekPlayback(clip.start);
                }
                ensureClipEditData(clip);
                applyClipVisualTransform();
                renderComplementImageList();
                updateVideoProgress();
                if (appState.timeline.open) syncTimelineUi();
            }

            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 500);
            }

            function downloadManifest(clip) {
                const payload = {
                    exportedAt: new Date().toISOString(),
                    source: {
                        label: appState.sourceLabel,
                        type: appState.sourceKind,
                        url: appState.sourceSrc,
                        youtubeVideoId: appState.youtubeVideoId || null
                    },
                    clip: {
                        title: clip.title,
                        start: clip.start,
                        end: clip.end,
                        duration: roundTenth(clip.end - clip.start),
                        captions: clip.captions,
                        crop: clip.crop || { zoom: 100, x: 0, y: 0 },
                        overlays: clip.overlays || [],
                        fillerShots: clip.fillerShots || []
                    }
                };
                const fileName = `${slugify(clip.title)}.edit.json`;
                downloadBlob(new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }), fileName);
                return fileName;
            }

            function waitForMetadata(videoElement) {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        cleanup();
                        reject(new Error('Timed out loading clip source.'));
                    }, 15000);

                    const cleanup = () => {
                        clearTimeout(timeout);
                        videoElement.onloadedmetadata = null;
                        videoElement.onerror = null;
                    };

                    videoElement.onloadedmetadata = () => {
                        cleanup();
                        resolve();
                    };
                    videoElement.onerror = () => {
                        cleanup();
                        reject(new Error('Could not decode this video for export.'));
                    };
                });
            }

            function seekVideo(videoElement, timestamp) {
                return new Promise((resolve, reject) => {
                    const onSeeked = () => {
                        cleanup();
                        resolve();
                    };
                    const onError = () => {
                        cleanup();
                        reject(new Error('Unable to seek video during export.'));
                    };
                    const cleanup = () => {
                        videoElement.removeEventListener('seeked', onSeeked);
                        videoElement.removeEventListener('error', onError);
                    };
                    videoElement.addEventListener('seeked', onSeeked);
                    videoElement.addEventListener('error', onError);
                    try {
                        videoElement.currentTime = Math.max(0, timestamp);
                    } catch (_error) {
                        cleanup();
                        reject(new Error('Unable to access selected clip segment.'));
                    }
                });
            }

            async function exportClip(clip) {
                if (isYoutubeSource()) {
                    throw new Error('Exportar vídeo direto do YouTube no navegador é bloqueado por restrição da plataforma.');
                }
                if (!window.MediaRecorder) {
                    throw new Error('MediaRecorder is unavailable in this browser.');
                }

                const exportVideo = document.createElement('video');
                exportVideo.preload = 'auto';
                exportVideo.crossOrigin = 'anonymous';
                exportVideo.playsInline = true;
                exportVideo.src = appState.sourceSrc;

                await waitForMetadata(exportVideo);
                if (!exportVideo.captureStream) {
                    throw new Error('captureStream is unavailable for this source.');
                }

                const mimeType = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm'
                ].find((value) => MediaRecorder.isTypeSupported(value));

                if (!mimeType) {
                    throw new Error('No supported export codec found.');
                }

                const stream = exportVideo.captureStream();
                const chunks = [];
                const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 2500000 });

                await seekVideo(exportVideo, clip.start);

                return new Promise((resolve, reject) => {
                    const onTimeUpdate = () => {
                        if (exportVideo.currentTime >= clip.end || exportVideo.ended) {
                            if (recorder.state !== 'inactive') recorder.stop();
                        }
                    };

                    const cleanup = () => {
                        exportVideo.pause();
                        exportVideo.removeEventListener('timeupdate', onTimeUpdate);
                        exportVideo.src = '';
                    };

                    recorder.ondataavailable = (event) => {
                        if (event.data && event.data.size > 0) chunks.push(event.data);
                    };
                    recorder.onerror = () => {
                        cleanup();
                        reject(new Error('Browser blocked recording this source.'));
                    };
                    recorder.onstop = () => {
                        cleanup();
                        if (!chunks.length) {
                            reject(new Error('No recorded data was captured.'));
                            return;
                        }
                        resolve(new Blob(chunks, { type: mimeType }));
                    };

                    exportVideo.addEventListener('timeupdate', onTimeUpdate);
                    recorder.start(150);
                    exportVideo.play().catch(() => {
                        if (recorder.state !== 'inactive') recorder.stop();
                        reject(new Error('Playback failed while recording.'));
                    });
                });
            }

            async function handleExport() {
                const clip = getActiveClip();
                if (!clip) {
                    setEditorStatus('Select a clip before exporting.', 'error');
                    return;
                }

                if (renderBtn.disabled) return;
                renderBtn.disabled = true;
                const originalHtml = renderBtn.innerHTML;
                renderBtn.innerHTML = '<iconify-icon icon="solar:spinner-linear" class="animate-spin text-lg"></iconify-icon> <span>Rendering...</span>';
                setEditorStatus('Rendering clip export...', 'muted');

                try {
                    const blob = await exportClip(clip);
                    const fileName = `${slugify(clip.title)}.webm`;
                    downloadBlob(blob, fileName);
                    appState.exportCount += 1;
                    setEditorStatus(`Exported ${fileName}.`, 'success');
                    renderBtn.innerHTML = '<iconify-icon icon="solar:check-circle-linear" class="text-lg"></iconify-icon> <span>Exported!</span>';
                    renderBtn.classList.add('bg-accent');
                    renderBtn.classList.remove('bg-white');
                } catch (error) {
                    const fallbackName = downloadManifest(clip);
                    setEditorStatus(`${error.message} Downloaded ${fallbackName} instead.`, 'error');
                    renderBtn.innerHTML = '<iconify-icon icon="solar:document-linear" class="text-lg"></iconify-icon> <span>Manifest Saved</span>';
                } finally {
                    setTimeout(() => {
                        renderBtn.innerHTML = originalHtml;
                        renderBtn.classList.add('bg-white');
                        renderBtn.classList.remove('bg-accent');
                        renderBtn.disabled = false;
                    }, 2200);
                    updateWorkflowGuide();
                }
            }

            function connectSpace(spaceName, options = {}) {
                const opts = options || {};
                const normalized = String(spaceName || '').trim();
                if (!normalized) {
                    if (!opts.silent) appendSpaceOutput('Digite um nome de Space para conectar.', 'error');
                    return false;
                }
                appState.space.connected = true;
                appState.space.name = normalized;
                if (spaceNameInput) spaceNameInput.value = normalized;
                updateSpaceStatus();
                if (!opts.silent) appendSpaceOutput(`Space conectado: ${normalized}`, 'success');
                return true;
            }

            async function generateThumbnailAsset(clip) {
                if (!clip) throw new Error('Nenhum clip selecionado para thumb.');

                const canvas = document.createElement('canvas');
                canvas.width = 1080;
                canvas.height = 1920;
                const ctx = canvas.getContext('2d');
                if (!ctx) throw new Error('Canvas indisponível para gerar thumb.');

                let drewFrame = false;
                const isLocalPlayable = !isYoutubeSource() && editorVideo.readyState >= 2;
                if (isLocalPlayable) {
                    try {
                        ctx.drawImage(editorVideo, 0, 0, canvas.width, canvas.height);
                        drewFrame = true;
                    } catch (_error) {
                        drewFrame = false;
                    }
                }

                if (!drewFrame) {
                    const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    grad.addColorStop(0, '#121212');
                    grad.addColorStop(0.45, '#1b2d05');
                    grad.addColorStop(1, '#060606');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                ctx.fillStyle = 'rgba(0,0,0,0.45)';
                ctx.fillRect(0, canvas.height - 720, canvas.width, 720);

                ctx.fillStyle = '#c8ff00';
                ctx.font = '700 46px "Space Grotesk", sans-serif';
                ctx.fillText('VOID CUT', 72, canvas.height - 580);

                ctx.fillStyle = '#ffffff';
                ctx.font = '700 74px "Syne", sans-serif';
                const title = clip.title.toUpperCase();
                const words = title.split(/\s+/);
                const lines = [];
                let line = '';
                words.forEach((word) => {
                    const candidate = line ? `${line} ${word}` : word;
                    if (ctx.measureText(candidate).width > canvas.width - 140) {
                        if (line) lines.push(line);
                        line = word;
                    } else {
                        line = candidate;
                    }
                });
                if (line) lines.push(line);
                lines.slice(0, 4).forEach((txt, idx) => {
                    ctx.fillText(txt, 72, canvas.height - 470 + idx * 92);
                });

                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.font = '500 36px "Space Grotesk", sans-serif';
                ctx.fillText(`#${appState.space.name || 'launch'}  ${formatTime(clip.end - clip.start)}`, 72, canvas.height - 90);

                const dataUrl = canvas.toDataURL('image/png');
                const name = `${slugify(clip.title)}-thumb.png`;
                return { name, dataUrl };
            }

            async function handleGenerateThumb(download = true) {
                const clip = getActiveClip();
                if (!clip) {
                    appendSpaceOutput('Selecione um clip antes de gerar thumbnail.', 'error');
                    return null;
                }

                const thumb = await generateThumbnailAsset(clip);
                appState.space.thumbs.unshift(thumb);
                appendSpaceOutput(`Thumbnail gerada: ${thumb.name}`, 'success');
                if (download) {
                    const res = await fetch(thumb.dataUrl);
                    const blob = await res.blob();
                    downloadBlob(blob, thumb.name);
                }
                return thumb;
            }

            function handleGenerateTitles() {
                const clip = getActiveClip();
                if (!clip) {
                    appendSpaceOutput('Selecione um clip antes de gerar títulos.', 'error');
                    return [];
                }

                const seeds = [
                    `${clip.title} (you are early)`,
                    `${clip.title}: the shift nobody saw coming`,
                    `Stop scrolling: ${clip.title}`,
                    `${clip.title} in under ${formatTime(clip.end - clip.start)}`,
                    `${clip.title} and why it matters now`
                ];
                appState.space.titles = seeds;
                appendSpaceOutput(`Gerados ${seeds.length} títulos.`, 'success');
                return seeds;
            }

            function handleGenerateHashtags() {
                const clip = getActiveClip();
                if (!clip) {
                    appendSpaceOutput('Selecione um clip antes de gerar hashtags.', 'error');
                    return [];
                }

                const baseWords = clip.title
                    .toLowerCase()
                    .replace(/[^a-z0-9\s]/g, ' ')
                    .split(/\s+/)
                    .filter((part) => part.length > 3)
                    .slice(0, 4);
                const tags = [
                    ...baseWords.map((word) => `#${word}`),
                    '#shorts',
                    '#viralclips',
                    '#creator',
                    '#contentstrategy'
                ];
                appState.space.hashtags = Array.from(new Set(tags));
                appendSpaceOutput(`Geradas ${appState.space.hashtags.length} hashtags.`, 'success');
                return appState.space.hashtags;
            }

            async function handleDownloadPack() {
                const clip = getActiveClip();
                if (!clip) {
                    appendSpaceOutput('Selecione um clip antes de baixar o pack.', 'error');
                    return;
                }

                if (!appState.space.titles.length) handleGenerateTitles();
                if (!appState.space.hashtags.length) handleGenerateHashtags();
                if (!appState.space.thumbs.length) {
                    try {
                        await handleGenerateThumb(false);
                    } catch (error) {
                        appendSpaceOutput(`Thumb pendente: ${error.message}`, 'error');
                    }
                }

                const payload = {
                    generatedAt: new Date().toISOString(),
                    space: {
                        name: appState.space.name || null,
                        connected: appState.space.connected
                    },
                    source: {
                        label: appState.sourceLabel,
                        kind: appState.sourceKind,
                        url: appState.sourceSrc
                    },
                    clip: {
                        title: clip.title,
                        start: clip.start,
                        end: clip.end,
                        duration: roundTenth(clip.end - clip.start),
                        crop: clip.crop || { zoom: 100, x: 0, y: 0 },
                        overlays: clip.overlays || [],
                        fillerShots: clip.fillerShots || []
                    },
                    captions: clip.captions,
                    style: appState.style,
                    audio: appState.audio,
                    titles: appState.space.titles,
                    hashtags: appState.space.hashtags,
                    thumbnails: appState.space.thumbs.map((thumb) => ({ name: thumb.name, dataUrl: thumb.dataUrl }))
                };

                const filename = `${slugify(clip.title)}-space-pack.json`;
                downloadBlob(new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }), filename);
                appendSpaceOutput(`Pack baixado: ${filename}`, 'success');
                appState.packCount += 1;
                updateWorkflowGuide();
            }

            function updateClipBoundary(which, rawValue, isDelta = false) {
                const clip = getActiveClip();
                if (!clip) return;
                const deltaOrValue = Number(rawValue);
                if (!Number.isFinite(deltaOrValue)) return;

                if (which === 'start') {
                    clip.start = isDelta ? clip.start + deltaOrValue : deltaOrValue;
                    clip.start = clamp(roundTenth(clip.start), 0, appState.duration - 0.2);
                    if (clip.start >= clip.end - 0.2) clip.end = roundTenth(clamp(clip.start + 0.2, 0.2, appState.duration));
                } else {
                    clip.end = isDelta ? clip.end + deltaOrValue : deltaOrValue;
                    clip.end = clamp(roundTenth(clip.end), 0.2, appState.duration);
                    if (clip.end <= clip.start + 0.2) clip.start = roundTenth(clamp(clip.end - 0.2, 0, appState.duration - 0.2));
                }

                syncClipCaptionsToTranscript(clip);
                syncClipUi(clip);
                if (appState.captionsSource === 'transcribed' && appState.transcriptWords.length) {
                    renderClipGrid();
                } else {
                    updateCardInfo(clip);
                }
                seekPlayback(clip.start);
                ensureClipEditData(clip);
                applyClipVisualTransform();
                renderComplementImageList();
                updateVideoProgress();
                if (appState.timeline.open) syncTimelineUi();
            }

            function buildDidacticChatGuide() {
                const stage = computeCurrentStage();
                if (stage === 1) {
                    return 'Passo 1/5: cole um link do YouTube ou envie um arquivo e clique em Generate Clips.';
                }
                if (stage === 2) {
                    return 'Passo 2/5: aguarde gerar os clips. Depois abra o clip com maior score.';
                }
                if (stage === 3) {
                    return 'Passo 3/5: ajuste start/end, título e estilo no editor. Dica: double click no clip abre timeline avançada.';
                }
                if (stage === 4) {
                    const blocked = getTranscribeBlockingReason();
                    if (blocked) return `Passo 4/5 bloqueado: ${blocked}`;
                    if (appState.sourceKind === 'youtube' || appState.sourceKind === 'link' || appState.sourceKind === 'ingested') {
                        return 'Passo 4/5: transcrição automática ativa para link. Execute "transcrever" só para reajustes.';
                    }
                    return 'Passo 4/5: execute "transcrever" para aplicar legendas temporizadas em todos os clips.';
                }
                if (appState.exportCount > 0 || appState.packCount > 0) {
                    return 'Fluxo completo. Use comandos como "caption size 48", "position top", "gerar thumb" para variações.';
                }
                return 'Passo 5/5: renderize o vídeo, abra o Automar Space, use a aba Complementar Vídeo para preencher gaps e rode "download pack".';
            }

            async function runCommand(rawCommand) {
                const command = String(rawCommand || '').trim();
                if (!command) return;
                addChatMessage('user', command);

                const normalized = normalizeCommand(command);
                const clip = getActiveClip();

                const sizeMatch = normalized.match(/caption(?:s)?\s+size\s+(\d{1,2})/);
                const colorMatch = normalized.match(/caption(?:s)?\s+color\s+(#[0-9a-f]{6})/);
                const bgOpacityMatch = normalized.match(/bg\s+opacity\s+(\d{1,3})/);
                const musicMatch = normalized.match(/music\s+(\d{1,3})/);
                const voiceMatch = normalized.match(/voice\s+(\d{1,3})/);
                const connectSpaceMatch = normalized.match(/(?:connect|conectar|ligar)\s+(?:to\s+)?space\s+(.+)$/);
                const openAutomationMatch = /^(?:open|abrir)\s+(?:automar|automation|space hub|space)$/.test(normalized);
                const trimStartMatch = normalized.match(/trim\s+start\s*([+-]\d+(\.\d+)?|\d+(\.\d+)?)/);
                const trimEndMatch = normalized.match(/trim\s+end\s*([+-]\d+(\.\d+)?|\d+(\.\d+)?)/);
                const trimGenericMatch = normalized.match(/^trim\s*([+-]?\d+(\.\d+)?)s?$/);
                const cropZoomMatch = normalized.match(/crop\s+zoom\s+(-?\d{1,3})/);
                const cropXMatch = normalized.match(/crop\s+x\s+(-?\d{1,3})/);
                const cropYMatch = normalized.match(/crop\s+y\s+(-?\d{1,3})/);
                const addTextMatch = command.match(/^(?:add|adicionar)\s+text[:\s]+(.+)$/i);
                const clipMatch = normalized.match(/^clip\s+(\d+)$/);
                const openTimelineMatch = /^(?:timeline|open timeline|abrir timeline)$/.test(normalized);
                const openComplementTabMatch = /^(?:complementar|complement|abrir complementar|open complement|aba complementar)$/.test(normalized);
                const complementGapsMatch = /(?:gerar|generate).*(?:gaps|lacunas|espacos vazios|espacos|espaços vazios|silencio|silêncio)/.test(normalized);
                const complementPromptMatch = command.match(/^(?:fill|complementar|complement)\s*[:\-]\s*(.+)$/i);
                const connectAgentMatch = normalized.match(/^(connect|conectar)\s+agent$/);
                const disconnectAgentMatch = normalized.match(/^(disconnect|desconectar)\s+agent$/);
                const agentIdMatch = command.match(/^agent\s+id[:\s]+([a-zA-Z0-9_]+)$/i);
                const helpMatch = /^(help|ajuda|tutorial|guia|socorro)$/.test(normalized);
                const backendDiagMatch = /^(diagnostico|diagnostico backend|status backend|check backend|diag)$/.test(normalized);

                try {
                    if (helpMatch) {
                        addChatMessage('assistant', buildDidacticChatGuide());
                        return;
                    }
                    if (backendDiagMatch) {
                        await refreshBackendHealth(true);
                        addChatMessage('assistant', buildBackendDiagnosticMessage());
                        return;
                    }

                    if (normalized.includes('uppercase') || /\bupper\b/.test(normalized)) {
                        appState.style.textCase = 'uppercase';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Captions em UPPERCASE.');
                        return;
                    }
                    if (normalized.includes('lowercase') || /\blower\b/.test(normalized)) {
                        appState.style.textCase = 'lowercase';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Captions em lowercase.');
                        return;
                    }
                    if (normalized.includes('normal case')) {
                        appState.style.textCase = 'normal';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Captions em estilo normal.');
                        return;
                    }
                    if (normalized.includes('font syne') || normalized.includes('font display')) {
                        appState.style.fontFamily = 'display';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Fonte das captions: Syne.');
                        return;
                    }
                    if (normalized.includes('font mono')) {
                        appState.style.fontFamily = 'mono';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Fonte das captions: Mono.');
                        return;
                    }
                    if (normalized.includes('font space') || normalized.includes('font body')) {
                        appState.style.fontFamily = 'body';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Fonte das captions: Space Grotesk.');
                        return;
                    }
                    if (normalized.includes('neon')) {
                        appState.style.textColor = '#c8ff00';
                        appState.style.bgColor = '#001100';
                        appState.style.bgOpacity = 36;
                        appState.style.strokeColor = '#000000';
                        appState.style.strokeSize = 2;
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Preset neon aplicado.');
                        return;
                    }
                    if (sizeMatch) {
                        appState.style.fontSize = clamp(parseInt(sizeMatch[1], 10), 20, 72);
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', `Caption size ajustado para ${appState.style.fontSize}px.`);
                        return;
                    }
                    if (colorMatch) {
                        appState.style.textColor = colorMatch[1];
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', `Cor da caption: ${colorMatch[1]}.`);
                        return;
                    }
                    if (bgOpacityMatch) {
                        appState.style.bgOpacity = clamp(parseInt(bgOpacityMatch[1], 10), 0, 100);
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', `Opacidade de fundo: ${appState.style.bgOpacity}%.`);
                        return;
                    }
                    if (normalized.includes('position top')) {
                        appState.style.position = 'top';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Caption position: top.');
                        return;
                    }
                    if (normalized.includes('position middle')) {
                        appState.style.position = 'middle';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Caption position: middle.');
                        return;
                    }
                    if (normalized.includes('position bottom')) {
                        appState.style.position = 'bottom';
                        syncCaptionStyleControls();
                        applyCaptionStyle();
                        addChatMessage('assistant', 'Caption position: bottom.');
                        return;
                    }
                    if (musicMatch) {
                        appState.audio.music = clamp(parseInt(musicMatch[1], 10), 0, 100);
                        updateAudioUi();
                        addChatMessage('assistant', `Music volume: ${appState.audio.music}%.`);
                        return;
                    }
                    if (voiceMatch) {
                        appState.audio.voice = clamp(parseInt(voiceMatch[1], 10), 0, 100);
                        updateAudioUi();
                        addChatMessage('assistant', `Voice volume: ${appState.audio.voice}%.`);
                        return;
                    }
                    if (trimStartMatch && clip) {
                        const rawValue = trimStartMatch[1];
                        const numeric = Number(rawValue);
                        updateClipBoundary('start', numeric, /^[+-]/.test(rawValue));
                        addChatMessage('assistant', `Start ajustado para ${clip.start.toFixed(1)}s.`);
                        return;
                    }
                    if (trimEndMatch && clip) {
                        const rawValue = trimEndMatch[1];
                        const numeric = Number(rawValue);
                        updateClipBoundary('end', numeric, /^[+-]/.test(rawValue));
                        addChatMessage('assistant', `End ajustado para ${clip.end.toFixed(1)}s.`);
                        return;
                    }
                    if (trimGenericMatch && clip) {
                        const rawValue = trimGenericMatch[1];
                        const numeric = Number(rawValue);
                        updateClipBoundary('end', numeric, /^[+-]/.test(rawValue));
                        addChatMessage('assistant', `Trim aplicado. End em ${clip.end.toFixed(1)}s.`);
                        return;
                    }
                    if ((cropZoomMatch || cropXMatch || cropYMatch) && clip) {
                        ensureClipEditData(clip);
                        if (cropZoomMatch) clip.crop.zoom = clamp(parseInt(cropZoomMatch[1], 10) || clip.crop.zoom, 100, 180);
                        if (cropXMatch) clip.crop.x = clamp(parseInt(cropXMatch[1], 10) || clip.crop.x, -40, 40);
                        if (cropYMatch) clip.crop.y = clamp(parseInt(cropYMatch[1], 10) || clip.crop.y, -40, 40);
                        applyClipVisualTransform();
                        if (appState.timeline.open) syncTimelineUi();
                        addChatMessage('assistant', `Crop atualizado: zoom ${clip.crop.zoom}%, x ${clip.crop.x}%, y ${clip.crop.y}%.`);
                        return;
                    }
                    if (addTextMatch && clip) {
                        ensureClipEditData(clip);
                        const overlayText = addTextMatch[1].trim();
                        if (overlayText) {
                            const y = Math.min(90, 20 + (clip.overlays.length % 5) * 12);
                            clip.overlays.push({
                                id: `ov-${Date.now()}-${Math.round(Math.random() * 10000)}`,
                                text: overlayText,
                                x: 50,
                                y
                            });
                            renderClipOverlays(clip);
                            if (appState.timeline.open) syncTimelineUi();
                            addChatMessage('assistant', `Overlay adicionado: "${overlayText}".`);
                        }
                        return;
                    }
                    if (openAutomationMatch) {
                        if (openVideoAutomationSpace(spaceNameInput.value.trim() || appState.space.name || 'automar-video-space')) {
                            addChatMessage('assistant', `Automar Space aberto: ${appState.space.name}.`);
                        }
                        return;
                    }
                    if (openComplementTabMatch) {
                        switchEditorTab('complement');
                        addChatMessage('assistant', 'Aba Complementar Vídeo aberta.');
                        return;
                    }
                    if (complementGapsMatch) {
                        switchEditorTab('complement');
                        await generateComplementForSpeechGaps({ regenerate: false });
                        addChatMessage('assistant', 'Geração de complementos para gaps iniciada/concluída.');
                        return;
                    }
                    if (complementPromptMatch) {
                        switchEditorTab('complement');
                        await runComplementChat(complementPromptMatch[1].trim());
                        addChatMessage('assistant', 'Prompt de complemento processado.');
                        return;
                    }
                    if (connectSpaceMatch) {
                        const name = connectSpaceMatch[1].trim();
                        if (openVideoAutomationSpace(name)) addChatMessage('assistant', `Space conectado e automação aberta: ${appState.space.name}.`);
                        return;
                    }
                    if (openTimelineMatch) {
                        const targetClip = getActiveClip() || appState.clips[0];
                        if (!targetClip) {
                            addChatMessage('assistant', 'Gere clips antes de abrir timeline.');
                            return;
                        }
                        await openTimelineEditor(targetClip.id, false);
                        addChatMessage('assistant', `Timeline aberta para ${targetClip.title}.`);
                        return;
                    }
                    if (normalized.includes('thumb now') || normalized.includes('generate thumb') || normalized.includes('gerar thumb') || normalized.includes('gerar thumbnail')) {
                        try {
                            await handleGenerateThumb(true);
                            addChatMessage('assistant', 'Thumbnail gerada e baixada.');
                        } catch (error) {
                            addChatMessage('assistant', `Falha na thumb: ${error.message}`);
                        }
                        return;
                    }
                    if (normalized.includes('titles now') || normalized.includes('generate titles') || normalized.includes('gerar titulos') || normalized.includes('gerar títulos')) {
                        const titles = handleGenerateTitles();
                        addChatMessage('assistant', titles.length ? `Títulos prontos: ${titles.length}.` : 'Sem clip ativo para títulos.');
                        return;
                    }
                    if (normalized.includes('hashtags now') || normalized.includes('generate hashtags') || normalized.includes('gerar hashtags')) {
                        const tags = handleGenerateHashtags();
                        addChatMessage('assistant', tags.length ? `Hashtags prontas: ${tags.join(' ')}` : 'Sem clip ativo para hashtags.');
                        return;
                    }
                    if (normalized.includes('download pack') || normalized.includes('baixar pack')) {
                        await handleDownloadPack();
                        addChatMessage('assistant', 'Space pack gerado.');
                        return;
                    }
                    if (connectAgentMatch) {
                        try {
                            await connectElevenAgentSocket();
                            addChatMessage('assistant', 'Agent conectado.');
                        } catch (error) {
                            addChatMessage('assistant', `Falha ao conectar agent: ${error.message}`);
                        }
                        return;
                    }
                    if (disconnectAgentMatch) {
                        disconnectElevenAgentSocket();
                        setAgentStatus('Agent disconnected.', 'muted');
                        addChatMessage('assistant', 'Agent desconectado.');
                        return;
                    }
                    if (agentIdMatch) {
                        const nextId = agentIdMatch[1].trim();
                        disconnectElevenAgentSocket();
                        appState.elevenAgentId = nextId;
                        updateAgentBadge();
                        setAgentStatus(`Agent ID updated: ${nextId}`, 'success');
                        addChatMessage('assistant', `Agent ID atualizado para ${nextId}.`);
                        return;
                    }
                    if (normalized.includes('transcribe') || normalized.includes('transcrever') || normalized.includes('gerar legenda') || normalized.includes('legendas')) {
                        await handleTranscribeCaptions();
                        return;
                    }
                    if (clipMatch) {
                        const index = clamp(parseInt(clipMatch[1], 10) - 1, 0, appState.clips.length - 1);
                        const target = appState.clips[index];
                        if (target) {
                            await openClipEditor(target.id, true);
                            addChatMessage('assistant', `Clip ${index + 1} carregado.`);
                        }
                        return;
                    }

                    const agentReply = await askElevenAgent(command);
                    if (agentReply) {
                        addChatMessage('assistant', `[Agent] ${agentReply}`);
                        return;
                    }

                    addChatMessage('assistant', `Comando não reconhecido. ${buildDidacticChatGuide()}`);
                } finally {
                    updateWorkflowGuide();
                }
            }

            earlyAccessForm.addEventListener('submit', (event) => {
                event.preventDefault();
                earlyAccessBtn.innerHTML = '<iconify-icon icon="solar:spinner-linear" class="animate-spin" width="16" height="16"></iconify-icon> Opening Dashboard...';
                setTimeout(() => {
                    landingPage.classList.add('hidden');
                    appInterface.classList.remove('hidden');
                    setTimeout(() => appInterface.classList.remove('opacity-0'), 50);
                    window.scrollTo(0, 0);
                    earlyAccessBtn.innerHTML = 'Get Early Access <iconify-icon icon="solar:arrow-right-linear" width="16" height="16"></iconify-icon>';
                }, 350);
            });

            document.getElementById('homeLink').addEventListener('click', (event) => {
                event.preventDefault();
                appInterface.classList.add('hidden', 'opacity-0');
                landingPage.classList.remove('hidden');
                videoUrlInput.value = '';
                fileInput.value = '';
                dropText.textContent = 'Click to upload or drag & drop';
                setGenerateStatus('');
                setEditorStatus('');
                setTranscribeStatus('Envie um link para transcrição automática. Use Reajustar para recalibrar captions.', 'muted');
                resultsSection.classList.add('hidden', 'opacity-0');
                editorSection.classList.add('hidden', 'opacity-0');
                editorVideo.pause();
                editorVideo.removeAttribute('src');
                editorVideo.load();
                stopYoutubeProgressTicker();
                disconnectElevenAgentSocket();
                if (youtubePlayer && typeof youtubePlayer.stopVideo === 'function') {
                    try {
                        youtubePlayer.stopVideo();
                    } catch (_error) {
                        // noop
                    }
                }
                cleanupObjectUrl();
                setPreviewMode('link');
                appState.clips = [];
                appState.activeClipId = null;
                appState.activeCaptionId = null;
                appState.activeFilter = 'all';
                appState.activeThemeFilter = 'all';
                appState.activeSubjectFilter = 'all';
                applyClipVisualTransform();
                appState.sourceSrc = '';
                appState.sourceLabel = '';
                appState.sourceKind = '';
                appState.youtubeVideoId = '';
                appState.youtubePlaybackBlocked = false;
                appState.youtubePlaybackBlockReason = '';
                appState.ingestedMediaBlob = null;
                appState.duration = 0;
                appState.captionsSource = 'template';
                appState.transcriptWords = [];
                appState.transcribeInFlight = false;
                appState.exportCount = 0;
                appState.packCount = 0;
                appState.space = { connected: false, name: '', thumbs: [], titles: [], hashtags: [] };
                appState.automation = {
                    selectedNodeId: 'trigger_new_video',
                    successRate: 99.1,
                    nodes: buildDefaultAutomationNodes(),
                    templates: [],
                    ingest: null,
                    patchLayers: [],
                    renderPlan: null
                };
                appState.timeline = { open: false, clipId: null };
                appState.clipboard = { clipStyle: null, crop: null };
                appState.complement.busy = false;
                appState.complement.tab = 'captions';
                updateSpaceStatus();
                spaceNameInput.value = '';
                spaceOutputs.innerHTML = '';
                complementChatLog.innerHTML = '';
                complementImageList.innerHTML = '';
                setComplementStatus('Defina a key e peça para gerar imagens de preenchimento.', 'muted');
                switchEditorTab('captions');
                closeTimelineEditor();
                closeVideoAutomationSpace();
                setAgentStatus('Agent disconnected.', 'muted');
                agentConnectBtn.textContent = 'Connect Agent';
                sourceSummary.textContent = 'Source: No video loaded yet';
                updateThemeSubjectFilterOptions();
                applyFilter('all');
                updateWorkflowGuide();
                refreshBackendHealth(false).catch(() => {});
            });

            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    dropText.innerHTML = `<span class="text-accent">${fileInput.files[0].name}</span>`;
                    setGenerateStatus('File selected. Click Generate Clips to analyze.', 'muted');
                } else {
                    dropText.textContent = 'Click to upload or drag & drop';
                }
            });

            generateForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const urlValue = videoUrlInput.value.trim();
                const file = fileInput.files[0];
                if (!urlValue && !file) {
                    setGenerateStatus('Paste a link or upload a video first.', 'error');
                    return;
                }

                const originalBtnHtml = generateBtn.innerHTML;
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<iconify-icon icon="solar:spinner-linear" class="animate-spin text-lg"></iconify-icon> <span>Loading Video...</span>';
                setGenerateStatus('Reading video metadata...', 'muted');
                processingCard.classList.remove('hidden');

                try {
                    const source = await loadSource(urlValue, file);
                    appState.sourceSrc = source.src;
                    appState.sourceLabel = source.label;
                    appState.sourceKind = source.sourceKind;
                    appState.youtubeVideoId = source.youtubeVideoId || '';
                    appState.youtubePlaybackBlocked = Boolean(source.youtubePlaybackBlocked);
                    appState.youtubePlaybackBlockReason = String(source.youtubePlaybackBlockReason || '');
                    appState.ingestedMediaBlob = source.ingestedMediaBlob || null;
                    appState.duration = source.duration;
                    appState.clips = buildClips(source.duration).map((clip) => ensureClipEditData(clip));
                    appState.captionsSource = 'template';
                    appState.transcriptWords = [];
                    appState.transcribeInFlight = false;
                    appState.exportCount = 0;
                    appState.packCount = 0;
                    appState.activeClipId = appState.clips[0] ? appState.clips[0].id : null;
                    appState.activeCaptionId = null;
                    appState.activeFilter = 'all';
                    appState.activeThemeFilter = 'all';
                    appState.activeSubjectFilter = 'all';
                    appState.space.thumbs = [];
                    appState.space.titles = [];
                    appState.space.hashtags = [];
                    appState.complement.busy = false;
                    appState.timeline.open = false;
                    appState.timeline.clipId = null;
                    closeTimelineEditor();
                    spaceOutputs.innerHTML = '';
                    complementImageList.innerHTML = '';

                    if (!appState.clips.length) {
                        throw new Error('No clips could be generated from this source.');
                    }

                    sourceSummary.textContent = `Source: ${source.label} (${formatTime(source.duration)})`;
                    updateFilterCounts();
                    renderClipGrid();
                    openClipEditor(appState.activeClipId, false);

                    resultsSection.classList.remove('hidden');
                    setTimeout(() => resultsSection.classList.remove('opacity-0'), 50);
                    resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    if (appState.youtubePlaybackBlocked) {
                        setGenerateStatus(`Generated ${appState.clips.length} clips. Preview YouTube limitado; edição e transcrição seguem ativas.`, 'muted');
                        addChatMessage('assistant', `Preview do YouTube indisponível para este vídeo: ${appState.youtubePlaybackBlockReason}`);
                    } else {
                        setGenerateStatus(`Generated ${appState.clips.length} clips from this video.`, 'success');
                    }
                    switchEditorTab('captions');
                    const shouldAutoTranscribe = !file && (appState.sourceKind === 'youtube' || appState.sourceKind === 'link' || appState.sourceKind === 'ingested');
                    if (shouldAutoTranscribe) {
                        setTranscribeStatus('Link detectado. Iniciando transcrição automática...', 'muted');
                        setTimeout(() => {
                            handleTranscribeCaptions({ automatic: true }).catch(() => {});
                        }, 120);
                    } else {
                        setTranscribeStatus('Use Reajustar para sincronizar/atualizar captions após ajustes de corte.', 'muted');
                    }
                    addChatMessage('assistant', `Project loaded: ${appState.clips.length} clips ready to edit.`);
                    refreshBackendHealth(false).catch(() => {});
                    updateWorkflowGuide();
                } catch (error) {
                    cleanupObjectUrl();
                    setGenerateStatus(error.message || 'Unable to generate clips.', 'error');
                    processingCard.classList.add('hidden');
                    updateWorkflowGuide();
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = originalBtnHtml;
                }
            });

            filterBtns.forEach((btn) => {
                btn.addEventListener('click', () => applyFilter(btn.dataset.filter));
            });

            if (themeFilterSelect) {
                themeFilterSelect.addEventListener('change', () => {
                    appState.activeThemeFilter = themeFilterSelect.value || 'all';
                    applyFilter(appState.activeFilter);
                });
            }

            if (subjectFilterSelect) {
                subjectFilterSelect.addEventListener('change', () => {
                    appState.activeSubjectFilter = subjectFilterSelect.value || 'all';
                    applyFilter(appState.activeFilter);
                });
            }

            clipGrid.addEventListener('click', async (event) => {
                const card = event.target.closest('.clip-card');
                if (!card) return;
                const clipId = card.dataset.clipId;
                if (!clipId) return;

                if (event.target.closest('.export-btn')) {
                    await openClipEditor(clipId, false);
                    await handleExport();
                    return;
                }
                if (event.target.closest('.edit-btn') || event.target.closest('.play-trigger')) {
                    await openClipEditor(clipId);
                }
            });

            clipGrid.addEventListener('dblclick', async (event) => {
                const card = event.target.closest('.clip-card');
                if (!card) return;
                if (event.target.closest('.export-btn')) return;
                const clipId = card.dataset.clipId;
                if (!clipId) return;
                const clip = appState.clips.find((item) => item.id === clipId);
                if (!clip) return;
                const opened = await openTimelineEditor(clipId, true);
                if (opened) addChatMessage('assistant', `Timeline avançada aberta para "${clip.title}".`);
            });

            editorTitle.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    editorTitle.blur();
                }
            });

            editorTitle.addEventListener('input', () => {
                const clip = getActiveClip();
                if (!clip) return;
                clip.title = (editorTitle.textContent || '').trim() || 'Untitled Clip';
                updateCardInfo(clip);
            });

            editorTitle.addEventListener('blur', () => {
                const clip = getActiveClip();
                if (!clip) return;
                editorTitle.textContent = clip.title;
            });

            clipStartInput.addEventListener('change', () => commitTimingInput('start'));
            clipEndInput.addEventListener('change', () => commitTimingInput('end'));

            captionList.addEventListener('focusin', (event) => {
                const row = event.target.closest('.caption-row');
                if (row) setActiveCaptionRow(row);
            });

            captionList.addEventListener('click', (event) => {
                const row = event.target.closest('.caption-row');
                if (!row) return;
                setActiveCaptionRow(row);
                const clip = getActiveClip();
                const time = Number(row.dataset.captionTime);
                if (clip && Number.isFinite(time)) {
                    seekPlayback(time);
                    updateVideoProgress();
                }
            });

            captionList.addEventListener('input', (event) => {
                const textarea = event.target.closest('textarea');
                if (!textarea) return;
                const row = textarea.closest('.caption-row');
                const clip = getActiveClip();
                if (!row || !clip) return;
                const captionId = row.dataset.captionId;
                const targetCaption = clip.captions.find((caption) => caption.id === captionId);
                if (targetCaption) {
                    targetCaption.text = textarea.value;
                    appState.activeCaptionId = captionId;
                }
                updateCaptionPreviewText();
            });

            [
                captionFontFamilySelect,
                captionWeightSelect,
                captionTextColorInput,
                captionBgColorInput,
                captionFontSizeInput,
                captionBgOpacityInput,
                captionPositionSelect,
                captionCaseSelect,
                captionStrokeColorInput,
                captionStrokeSizeInput
            ].forEach((input) => {
                const evt = input.type === 'range' || input.type === 'color' ? 'input' : 'change';
                input.addEventListener(evt, setStyleFromControls);
            });

            musicVolumeInput.addEventListener('input', () => {
                appState.audio.music = clamp(parseInt(musicVolumeInput.value, 10) || 0, 0, 100);
                updateAudioUi();
            });

            voiceVolumeInput.addEventListener('input', () => {
                appState.audio.voice = clamp(parseInt(voiceVolumeInput.value, 10) || 0, 0, 100);
                updateAudioUi();
            });

            editorTabBtns.forEach((btn) => {
                btn.addEventListener('click', () => {
                    switchEditorTab(btn.dataset.editorTab);
                });
            });

            complementProviderSelect.addEventListener('change', () => {
                appState.complement.provider = String(complementProviderSelect.value || 'openai').trim().toLowerCase();
                saveComplementProvider(appState.complement.provider);
                appState.complement.apiKey = getSavedComplementApiKey(appState.complement.provider);
                complementApiKeyInput.value = appState.complement.apiKey;
                setComplementStatus(`Provider: ${appState.complement.provider}.`, 'muted');
            });

            complementSaveKeyBtn.addEventListener('click', async () => {
                const key = String(complementApiKeyInput.value || '').trim();
                if (!key) {
                    setComplementStatus('Cole uma API key antes de salvar.', 'error');
                    return;
                }
                complementSaveKeyBtn.disabled = true;
                try {
                    appState.complement.apiKey = key;
                    saveComplementApiKey(appState.complement.provider, key);
                    await saveProviderKeyToBackend(appState.complement.provider, key);
                    setComplementStatus('API key salva localmente + Key Vault backend.', 'success');
                    appendAutomationInfraLog(`Key ${appState.complement.provider} salva no vault.`, 'success');
                } catch (error) {
                    setComplementStatus(`Key salva localmente, mas falhou no backend: ${error.message}`, 'error');
                    appendAutomationInfraLog(`Falha ao salvar key no vault: ${error.message}`, 'error');
                } finally {
                    complementSaveKeyBtn.disabled = false;
                }
            });

            complementClearKeyBtn.addEventListener('click', () => {
                complementApiKeyInput.value = '';
                appState.complement.apiKey = '';
                clearComplementApiKey(appState.complement.provider);
                setComplementStatus('API key removida do armazenamento local.', 'muted');
            });

            complementChatSendBtn.addEventListener('click', async () => {
                const text = String(complementChatInput.value || '').trim();
                if (!text) return;
                complementChatInput.value = '';
                await runComplementChat(text);
            });

            complementChatInput.addEventListener('keydown', async (event) => {
                if (event.key !== 'Enter') return;
                event.preventDefault();
                const text = String(complementChatInput.value || '').trim();
                if (!text) return;
                complementChatInput.value = '';
                await runComplementChat(text);
            });

            complementAutoFillBtn.addEventListener('click', async () => {
                await generateComplementForSpeechGaps({ regenerate: false });
            });

            complementRegenerateBtn.addEventListener('click', async () => {
                await generateComplementForSpeechGaps({ regenerate: true });
            });

            complementImageList.addEventListener('click', (event) => {
                const jumpButton = event.target.closest('[data-complement-jump]');
                if (jumpButton) {
                    const clip = getActiveClip();
                    if (!clip) return;
                    const shot = clip.fillerShots.find((item) => item.id === jumpButton.dataset.complementJump);
                    if (!shot) return;
                    seekPlayback(shot.start);
                    updateVideoProgress();
                    setComplementStatus(`Playhead em ${formatTime(shot.start)}.`, 'success');
                    return;
                }

                const removeButton = event.target.closest('[data-complement-remove]');
                if (removeButton) {
                    const clip = getActiveClip();
                    if (!clip) return;
                    const before = clip.fillerShots.length;
                    clip.fillerShots = clip.fillerShots.filter((item) => item.id !== removeButton.dataset.complementRemove);
                    if (clip.fillerShots.length !== before) {
                        renderComplementImageList();
                        applyClipVisualTransform();
                        setComplementStatus('Imagem complementar removida.', 'success');
                    }
                }
            });

            connectSpaceBtn.addEventListener('click', () => {
                const name = spaceNameInput.value.trim();
                if (openVideoAutomationSpace(name)) {
                    addChatMessage('assistant', `Space conectado e workspace aberto: ${appState.space.name}.`);
                }
            });

            spaceNameInput.addEventListener('keydown', (event) => {
                if (event.key !== 'Enter') return;
                event.preventDefault();
                const name = spaceNameInput.value.trim();
                if (openVideoAutomationSpace(name)) addChatMessage('assistant', `Space conectado e workspace aberto: ${appState.space.name}.`);
            });

            generateThumbBtn.addEventListener('click', async () => {
                try {
                    await handleGenerateThumb(true);
                } catch (error) {
                    appendSpaceOutput(error.message, 'error');
                }
            });

            generateTitlesBtn.addEventListener('click', () => {
                const titles = handleGenerateTitles();
                if (titles.length) appendSpaceOutput(titles.join(' | '), 'neutral');
            });

            generateHashtagsBtn.addEventListener('click', () => {
                const tags = handleGenerateHashtags();
                if (tags.length) appendSpaceOutput(tags.join(' '), 'neutral');
            });

            downloadPackBtn.addEventListener('click', async () => {
                await handleDownloadPack();
            });

            openTimelineBtn.addEventListener('click', async () => {
                const targetClip = getActiveClip() || appState.clips[0];
                if (!targetClip) {
                    setEditorStatus('Gere e selecione um clip antes de abrir a timeline.', 'error');
                    return;
                }
                await openTimelineEditor(targetClip.id, false);
            });

            videoAutomationCloseBtn.addEventListener('click', () => {
                closeVideoAutomationSpace();
            });

            videoAutomationModal.addEventListener('click', (event) => {
                if (event.target === videoAutomationModal) closeVideoAutomationSpace();
            });

            automarNodeButtons.forEach((button) => {
                button.addEventListener('click', () => {
                    selectAutomationNode(button.dataset.automarNode);
                });
            });

            automationNodeSaveBtn.addEventListener('click', () => {
                saveAutomationNodeConfig();
            });

            automationApplyPromptBtn.addEventListener('click', () => {
                applyAutomationPrompt();
            });

            automationPromptInput.addEventListener('keydown', (event) => {
                if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
                    event.preventDefault();
                    applyAutomationPrompt();
                }
            });

            automationRunBtn.addEventListener('click', () => {
                ensureAutomationState();
                appState.automation.successRate = clamp(appState.automation.successRate + 0.1, 90, 100);
                renderAutomationNodesUi();
                setAutomationPromptStatus('Test run concluído com sucesso.', 'success');
                appendSpaceOutput('Automar test run finalizado.', 'success');
            });

            automationDeployBtn.addEventListener('click', () => {
                ensureAutomationState();
                renderAutomationNodesUi();
                setAutomationPromptStatus('Workflow deployado no Space Hub.', 'success');
                addChatMessage('assistant', `Workflow "${appState.space.name || 'automar-video-space'}" deployado.`);
            });

            automationIngestBtn.addEventListener('click', async () => {
                automationIngestBtn.disabled = true;
                try {
                    await runAutomationIngest();
                } catch (error) {
                    setAutomationInfraStatus(error.message || 'Falha ao rodar ingest.', 'error');
                    appendAutomationInfraLog(error.message || 'Falha no ingest.', 'error');
                } finally {
                    automationIngestBtn.disabled = false;
                }
            });

            automationLoadTemplatesBtn.addEventListener('click', async () => {
                automationLoadTemplatesBtn.disabled = true;
                try {
                    await loadWorkflowTemplatesFromBackend();
                } catch (error) {
                    setAutomationInfraStatus(error.message || 'Falha ao carregar templates.', 'error');
                    appendAutomationInfraLog(error.message || 'Falha ao carregar templates.', 'error');
                } finally {
                    automationLoadTemplatesBtn.disabled = false;
                }
            });

            automationCreatePatchBtn.addEventListener('click', async () => {
                automationCreatePatchBtn.disabled = true;
                try {
                    await createAutomationFramePatch();
                } catch (error) {
                    setAutomationInfraStatus(error.message || 'Falha ao criar patch.', 'error');
                    appendAutomationInfraLog(error.message || 'Falha ao criar patch.', 'error');
                } finally {
                    automationCreatePatchBtn.disabled = false;
                }
            });

            automationExecutePatchBtn.addEventListener('click', async () => {
                automationExecutePatchBtn.disabled = true;
                try {
                    await executeAutomationFramePatch();
                } catch (error) {
                    setAutomationInfraStatus(error.message || 'Falha ao executar patch.', 'error');
                    appendAutomationInfraLog(error.message || 'Falha ao executar patch.', 'error');
                } finally {
                    automationExecutePatchBtn.disabled = false;
                }
            });

            automationPlanRenderBtn.addEventListener('click', async () => {
                automationPlanRenderBtn.disabled = true;
                try {
                    await planAutomationIncrementalRender();
                } catch (error) {
                    setAutomationInfraStatus(error.message || 'Falha ao planejar render.', 'error');
                    appendAutomationInfraLog(error.message || 'Falha ao planejar render.', 'error');
                } finally {
                    automationPlanRenderBtn.disabled = false;
                }
            });

            automationExecuteRenderBtn.addEventListener('click', async () => {
                automationExecuteRenderBtn.disabled = true;
                try {
                    await executeAutomationIncrementalRender();
                } catch (error) {
                    setAutomationInfraStatus(error.message || 'Falha ao executar render.', 'error');
                    appendAutomationInfraLog(error.message || 'Falha ao executar render.', 'error');
                } finally {
                    automationExecuteRenderBtn.disabled = false;
                }
            });

            timelineCloseBtn.addEventListener('click', () => {
                closeTimelineEditor();
            });

            timelineModal.addEventListener('click', (event) => {
                if (event.target === timelineModal) closeTimelineEditor();
            });

            timelineScrubber.addEventListener('input', () => {
                const clip = getTimelineClip();
                if (!clip) return;
                const playhead = getTimelinePlayhead();
                seekPlayback(playhead);
                syncTimelineUi();
            });

            timelinePlayBtn.addEventListener('click', async () => {
                const clip = getTimelineClip();
                if (!clip) return;
                try {
                    if (getPlaybackStateIsPlaying()) pausePlayback();
                    else await playPlayback();
                } catch (error) {
                    setTimelineStatus(error.message || 'Falha ao reproduzir.', 'error');
                }
            });

            timelineSetInBtn.addEventListener('click', () => applyTimelineCut('in'));
            timelineSetOutBtn.addEventListener('click', () => applyTimelineCut('out'));
            timelineCutLeftBtn.addEventListener('click', () => applyTimelineCut('in'));
            timelineCutRightBtn.addEventListener('click', () => applyTimelineCut('out'));
            timelineResetBtn.addEventListener('click', () => resetTimelineCut());

            [timelineCropZoom, timelineCropX, timelineCropY].forEach((slider) => {
                slider.addEventListener('input', () => applyTimelineCrop());
            });

            timelineAddOverlayBtn.addEventListener('click', () => addTimelineOverlay());

            timelineOverlayTextInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    addTimelineOverlay();
                }
            });

            timelineOverlayList.addEventListener('click', (event) => {
                const removeBtn = event.target.closest('[data-remove-overlay]');
                if (!removeBtn) return;
                removeTimelineOverlay(removeBtn.dataset.removeOverlay);
            });

            timelineCopyStyleBtn.addEventListener('click', () => copyClipStyleToClipboard());
            timelinePasteStyleBtn.addEventListener('click', () => pasteClipStyleFromClipboard());

            timelineOpenEditorBtn.addEventListener('click', () => {
                editorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                closeTimelineEditor();
            });

            guideFocusSourceBtn.addEventListener('click', () => {
                inputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                videoUrlInput.focus();
            });

            guideOpenEditorBtn.addEventListener('click', async () => {
                if (!appState.clips.length) {
                    setGenerateStatus('Gere os clips primeiro para abrir o editor.', 'error');
                    return;
                }
                const target = getActiveClip() || appState.clips[0];
                if (!target) return;
                await openClipEditor(target.id, true);
            });

            guideTranscribeBtn.addEventListener('click', async () => {
                await handleTranscribeCaptions();
                editorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });

            guideExportBtn.addEventListener('click', async () => {
                await handleExport();
            });

            guidePackBtn.addEventListener('click', async () => {
                await handleDownloadPack();
            });

            guideDiagnoseBtn.addEventListener('click', async () => {
                await refreshBackendHealth(true);
                addChatMessage('assistant', buildBackendDiagnosticMessage());
            });

            if (commandShortcutBar) {
                commandShortcutBar.addEventListener('click', async (event) => {
                    const shortcut = event.target.closest('.command-shortcut');
                    if (!shortcut) return;
                    const command = shortcut.dataset.command;
                    if (!command) return;
                    await runCommand(command);
                });
            }

            playBtn.addEventListener('click', async () => {
                const clip = getActiveClip();
                if (!clip) {
                    setEditorStatus('Select a clip first.', 'error');
                    return;
                }

                try {
                    if (!getPlaybackStateIsPlaying()) {
                        const currentTime = getPlaybackCurrentTime();
                        if (!Number.isFinite(currentTime) || currentTime < clip.start || currentTime >= clip.end) {
                            seekPlayback(clip.start);
                        }
                        await playPlayback();
                    } else {
                        pausePlayback();
                    }
                } catch (error) {
                    setEditorStatus(error.message || 'Playback failed for this source.', 'error');
                }
            });

            editorVideo.addEventListener('timeupdate', updateVideoProgress);
            editorVideo.addEventListener('play', () => playIcon.setAttribute('icon', 'solar:pause-bold'));
            editorVideo.addEventListener('pause', () => playIcon.setAttribute('icon', 'solar:play-bold'));

            progressTrack.addEventListener('click', (event) => {
                const clip = getActiveClip();
                if (!clip) return;
                const rect = progressTrack.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
                seekPlayback(clip.start + (clip.end - clip.start) * pct);
                updateVideoProgress();
            });

            renderBtn.addEventListener('click', handleExport);
            transcribeCaptionsBtn.addEventListener('click', () => {
                handleTranscribeCaptions().catch(() => {});
            });
            saveYoutubeCookiesBtn.addEventListener('click', () => {
                const raw = String(youtubeCookiesInput.value || '').trim();
                if (!raw) {
                    setYoutubeCookiesStatus('Cole as cookies antes de salvar.', 'error');
                    return;
                }
                appState.youtubeCookies = raw;
                saveYoutubeCookies(raw);
                setYoutubeCookiesStatus('Cookies salvos localmente. Próxima transcrição já envia para o backend.', 'success');
                refreshBackendHealth(true).catch(() => {});
            });
            clearYoutubeCookiesBtn.addEventListener('click', () => {
                appState.youtubeCookies = '';
                youtubeCookiesInput.value = '';
                clearSavedYoutubeCookies();
                setYoutubeCookiesStatus('Cookies locais removidos.', 'muted');
                refreshBackendHealth(true).catch(() => {});
            });

            commandSendBtn.addEventListener('click', async () => {
                const text = commandInput.value.trim();
                if (!text) return;
                commandInput.value = '';
                await runCommand(text);
            });

            agentConnectBtn.addEventListener('click', async () => {
                if (elevenAgentSocket && elevenAgentSocket.readyState === WebSocket.OPEN) {
                    disconnectElevenAgentSocket();
                    setAgentStatus('Agent disconnected.', 'muted');
                    agentConnectBtn.textContent = 'Connect Agent';
                    return;
                }
                try {
                    setAgentStatus('Connecting agent...', 'muted');
                    await connectElevenAgentSocket();
                    addChatMessage('assistant', `Agent conectado (${appState.elevenAgentId}).`);
                } catch (error) {
                    setAgentStatus(error.message || 'Falha ao conectar agent.', 'error');
                }
            });

            commandInput.addEventListener('keydown', async (event) => {
                if (event.key !== 'Enter') return;
                event.preventDefault();
                const text = commandInput.value.trim();
                if (!text) return;
                commandInput.value = '';
                await runCommand(text);
            });

            const SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognitionCtor) {
                speechRecognition = new SpeechRecognitionCtor();
                speechRecognition.lang = 'pt-BR';
                speechRecognition.interimResults = false;
                speechRecognition.maxAlternatives = 1;

                speechRecognition.onstart = () => {
                    voiceListening = true;
                    voiceStatus.textContent = 'Voice: listening...';
                    commandMicBtn.classList.add('border-accent/40', 'text-accent');
                };
                speechRecognition.onend = () => {
                    voiceListening = false;
                    voiceStatus.textContent = 'Voice: idle';
                    commandMicBtn.classList.remove('border-accent/40', 'text-accent');
                };
                speechRecognition.onerror = (event) => {
                    voiceStatus.textContent = `Voice error: ${event.error || 'unknown'}`;
                };
                speechRecognition.onresult = async (event) => {
                    const transcript = event.results[0][0].transcript.trim();
                    if (!transcript) return;
                    commandInput.value = transcript;
                    await runCommand(transcript);
                    commandInput.value = '';
                };
            } else {
                voiceStatus.textContent = 'Voice: unsupported in this browser';
                commandMicBtn.disabled = true;
                commandMicBtn.classList.add('opacity-40', 'cursor-not-allowed');
            }

            commandMicBtn.addEventListener('click', () => {
                if (!speechRecognition) return;
                if (voiceListening) speechRecognition.stop();
                else speechRecognition.start();
            });

            document.querySelectorAll('.custom-range').forEach((slider) => {
                slider.addEventListener('input', function onSliderInput() {
                    const val = ((this.value - this.min) / (this.max - this.min)) * 100;
                    const color = this.getAttribute('data-color') || '#c8ff00';
                    this.style.background = `linear-gradient(to right, ${color} ${val}%, rgba(255,255,255,0.1) ${val}%)`;
                    const label = this.nextElementSibling;
                    if (label && label.tagName === 'SPAN') label.innerText = `${this.value}%`;
                });
            });

            window.addEventListener('scroll', () => {
                const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
                const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                const scrolled = height > 0 ? winScroll / height : 0;
                document.getElementById('scrollProgress').style.transform = `scaleX(${scrolled})`;
            });

            window.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') return;
                if (appState.timeline.open) {
                    closeTimelineEditor();
                    return;
                }
                if (!videoAutomationModal.classList.contains('hidden')) {
                    closeVideoAutomationSpace();
                }
            });

            window.addEventListener('beforeunload', () => {
                cleanupObjectUrl();
                stopYoutubeProgressTicker();
                stopTimelineSync();
                if (speechRecognition && voiceListening) speechRecognition.stop();
                disconnectElevenAgentSocket();
            });
            ensureAutomationState();
            renderAutomationNodesUi();
            syncAutomationNodePanel();
            loadComplementSettings();
            loadYoutubeCookieSettings();
            switchEditorTab('captions');
            syncCaptionStyleControls();
            updateAudioUi();
            updateSpaceStatus();
            updateAgentBadge();
            setAgentStatus('Agent disconnected.', 'muted');
            setComplementStatus('Defina a key e peça para gerar imagens de preenchimento.', 'muted');
            if (!appState.youtubeCookies.trim()) {
                setYoutubeCookiesStatus('Salvo apenas neste navegador (opcional).', 'muted');
            }
            renderComplementImageList();
            applyCaptionStyle();
            addChatMessage('assistant', 'Command center online. Digite "ajuda" para seguir o passo a passo do fluxo.');
            addComplementMessage('assistant', 'Aba pronta. Ex: "gerar para gaps" ou descreva uma cena para preencher o espaço vazio.');
            updateThemeSubjectFilterOptions();
            applyFilter('all');
            setTranscribeStatus('Envie um link para transcrição automática. Use Reajustar para recalibrar captions.', 'muted');
            setGenerateStatus('Cole link do YouTube, link direto de vídeo (mp4/webm/mov) ou envie um arquivo para começar.', 'muted');
            updateWorkflowGuide();
            refreshBackendHealth(true).catch(() => {});
        });
    </script>

</body></html>
